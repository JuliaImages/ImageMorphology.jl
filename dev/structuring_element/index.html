<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structuring element · ImageMorphology</title><meta name="title" content="Structuring element · ImageMorphology"/><meta property="og:title" content="Structuring element · ImageMorphology"/><meta property="twitter:title" content="Structuring element · ImageMorphology"/><meta name="description" content="Documentation for ImageMorphology."/><meta property="og:description" content="Documentation for ImageMorphology."/><meta property="twitter:description" content="Documentation for ImageMorphology."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../democards/listtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImageMorphology</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">ImageMorphology.jl</a></li><li class="is-active"><a class="tocitem" href>Structuring element</a><ul class="internal"><li><a class="tocitem" href="#The-erosion-example"><span>The erosion example</span></a></li><li><a class="tocitem" href="#Two-neighborhood-representations"><span>Two neighborhood representations</span></a></li><li><a class="tocitem" href="#The-strel-function"><span>The <code>strel</code> function</span></a></li><li><a class="tocitem" href="#concept_symmetric"><span>Symmetricity</span></a></li><li><a class="tocitem" href="#Convenient-constructors"><span>Convenient constructors</span></a></li><li><a class="tocitem" href="#Performance-optimizations-and-the-strel_type-function"><span>Performance optimizations and the <code>strel_type</code> function</span></a></li></ul></li><li><a class="tocitem" href="../operators/">Morphology Operators</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Structuring element</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Structuring element</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaImages/ImageMorphology.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/master/docs/src/structuring_element.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="concept_se"><a class="docs-heading-anchor" href="#concept_se">Structuring element</a><a id="concept_se-1"></a><a class="docs-heading-anchor-permalink" href="#concept_se" title="Permalink"></a></h1><p>Structuring Element (SE) is the key concept in morphology to indicate the connectivity and the neighborhood. This page explains this structuring element concept, and how ImageMorphology supports the general SEs without compromising the performance on the most commonly used special SE cases.</p><h2 id="The-erosion-example"><a class="docs-heading-anchor" href="#The-erosion-example">The erosion example</a><a id="The-erosion-example-1"></a><a class="docs-heading-anchor-permalink" href="#The-erosion-example" title="Permalink"></a></h2><p>The erosion <code>erode</code> function in its simplest 1-dimensional case can be defined as</p><p class="math-container">\[\varepsilon_A[p] = min(A[p-1], A[p], A[p+1])\]</p><p>Because the output value at position <span>$p$</span> not only depends on its own pixel <code>A[p]</code> but also on its neighborhood values <code>A[p-1]</code> and <code>A[p+1]</code>, we call this type of operation a <em>neighborhood image transformation</em>.</p><p>Now comes the question: <strong>if we try to generalize the <code>erode</code> function, what should we do?</strong> – we would like to generalize the concept of &quot;neighborhood&quot;.</p><h2 id="Two-neighborhood-representations"><a class="docs-heading-anchor" href="#Two-neighborhood-representations">Two neighborhood representations</a><a id="Two-neighborhood-representations-1"></a><a class="docs-heading-anchor-permalink" href="#Two-neighborhood-representations" title="Permalink"></a></h2><p>By saying &quot;<span>$\Omega_p$</span> is the neighborhood of <span>$p$</span>&quot;, we are expressing <code>p in Ωₚ</code> in plain Julia. For performance consideration, this <code>Ωₚ</code> is usually generated from the <code>(p, Ω)</code> pair. <code>p</code> is the center point that changes during the iteration, and <code>Ω</code> is usually a pre-defined and unchanged data which contains the neighborhood and shape information. We call this <code>Ω</code> a <em>structuring element</em>. There are usually two ways to express <code>Ω</code>:</p><ul><li><strong>displacement offset</strong>: a list of <code>CartesianIndex</code> to indicate the offset to the center point <code>p</code></li><li><strong>connectivity mask</strong>: a bool array mask to indicate the connectivity to the center point <code>p</code></li></ul><p>For instance, in the following code block we build a commonly named C4 connectivity in the 2-dimensional case:</p><pre><code class="language-julia hljs"># displacement offset
Ω_offsets = [
    CartesianIndex(-1, 0),
    CartesianIndex(0, -1),
    CartesianIndex(0, 1),
    CartesianIndex(1, 0),
]

# connectivity mask
Ω_bool = Bool[
    0 1 0
    1 1 1
    0 1 0
]</code></pre><p>If <code>p=CartesianIndex(3, 3)</code>, then we know <code>p=CartesianIndex(3, 4)</code> is in <code>Ωₚ</code>.</p><p>Now, back to the erosion example. Based on the displacement offset representation, the simplest generic version of <code>erode</code> can be implemented quite simply:</p><pre><code class="language-julia hljs"># For illustration only, performance can be greatly improved using iteration to eliminate allocations
function my_erode(A, Ω)
    out = similar(A)
    R = CartesianIndices(A)
    for p in R
        Ωₚ = filter!(q-&gt;in(q, R), Ref(p) .+ Ω)
        # here we don&#39;t assume p in Ωₚ
        out[p] = min(A[p], minimum(A[Ωₚ]))
    end
    return out
end</code></pre><pre><code class="language-julia hljs">using ImageMorphology
using ImageBase
using TestImages

img = Gray.(testimage(&quot;morphology_test_512&quot;))
img = Gray.(img .&lt; 0.8)
img_e = my_erode(img, Ω_offsets)
mosaic(img, img_e; nrow=1)</code></pre><img src="a42c6414.png" alt="Example block output"/><p>As you may realize, the displacement offset representation is convenient to use when implementing algorithms, but it is hard to visualize. In contrast, the connectivity mask is not so convenient to use when implementing algorithms, but it is easy to visualize. For instance, one can very easily understand the following SE at the first glance:</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Bool}:
 1  1  1
 1  1  0
 0  0  0</code></pre><p>but not</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{CartesianIndex{2}}:
 CartesianIndex(-1, -1)
 CartesianIndex(0, -1)
 CartesianIndex(-1, 0)
 CartesianIndex(-1, 1)</code></pre><h2 id="The-strel-function"><a class="docs-heading-anchor" href="#The-strel-function">The <code>strel</code> function</a><a id="The-strel-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-strel-function" title="Permalink"></a></h2><p>This package supports the conversion between different SE representations via the <a href="../reference/#ImageMorphology.StructuringElements.strel"><code>strel</code></a> helper function. <code>strel</code> is the short name for &quot;STRucturing ELement&quot;.</p><p>To convert a connectivity mask representation to displacement offset representation:</p><pre><code class="language-julia hljs">Ω_mask = Bool[1 1 1; 1 1 0; 0 0 0] |&gt; centered
Ω_offsets = strel(CartesianIndex, Ω_mask)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{CartesianIndex{2}}:
 CartesianIndex(-1, -1)
 CartesianIndex(0, -1)
 CartesianIndex(-1, 0)
 CartesianIndex(-1, 1)</code></pre><div class="admonition is-info" id="zero-centered-mask-9531e8c9fde6d1d4"><header class="admonition-header">zero-centered mask<a class="admonition-anchor" href="#zero-centered-mask-9531e8c9fde6d1d4" title="Permalink"></a></header><div class="admonition-body"><p>The mask array is expected to be zero-centered. That means, the axes of a 3×3 mask <code>axes(se)</code> should be <code>(-1:1, -1:1)</code>. The <a href="../reference/#OffsetArrays.centered"><code>centered</code></a> function is used to shift the center point of the array to <code>(0, 0, ..., 0)</code>.</p><pre><code class="language-julia hljs">julia&gt; A = centered([1 2 3; 4 5 6; 7 8 9])
3×3 OffsetArray(::Matrix{Int64}, -1:1, -1:1) with eltype Int64 with indices -1:1×-1:1:
 1  2  3
 4  5  6
 7  8  9

julia&gt; A[-1, -1], A[0, 0], A[1, 1] # top-left, center, bottom-right
(1, 5, 9)</code></pre><p>This <code>centered</code> function comes from <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays.jl</a> and is also exported by ImageMorphology.</p></div></div><p>And to convert back from a displacement offset representation to connectivity mask representation:</p><pre><code class="language-julia hljs">strel(Bool, Ω_offsets)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 OffsetArray(::BitMatrix, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:
 1  1  1
 1  1  0
 0  0  0</code></pre><p>Quite simple, right? Thus to make our <code>my_erode</code> function more generic, we only need to add one single line:</p><pre><code class="language-diff hljs"> function my_erode(A, Ω)
     out = similar(A)
+    Ω = strel(CartesianIndex, Ω)
     R = CartesianIndices(A)</code></pre><h2 id="concept_symmetric"><a class="docs-heading-anchor" href="#concept_symmetric">Symmetricity</a><a id="concept_symmetric-1"></a><a class="docs-heading-anchor-permalink" href="#concept_symmetric" title="Permalink"></a></h2><p>Among all the structuring elements, the symmetric ones are used most in practice – they have better properties and their symmetry enables certain implementation optimizations.</p><p>The SE symmetricity is defined with respect to the center point for the mask representation <code>mask = strel(Bool, se)</code>: <code>se</code> is symmetric if <code>mask[I] == mask[-I]</code> holds for <code>I ∈ CartesianIndices(mask)</code>. – This is also why mask representation requires a <code>centered</code> array.</p><pre><code class="language-julia hljs">se = centered(Bool[
    1 0 1
    0 1 0
    1 0 1
])
ImageMorphology.is_symmetric(se) # true

se = centered(Bool[
    1 1 1
    0 1 0
    1 0 1
])
ImageMorphology.is_symmetric(se) # false

se = [CartesianIndex(1), CartesianIndex(-1)]
ImageMorphology.is_symmetric(se) # true

se = [CartesianIndex(1)]
ImageMorphology.is_symmetric(se) # false</code></pre><h2 id="Convenient-constructors"><a class="docs-heading-anchor" href="#Convenient-constructors">Convenient constructors</a><a id="Convenient-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Convenient-constructors" title="Permalink"></a></h2><p>Among all the SE possibilities, this package provides constructors for two commonly used cases:</p><ul><li>diamond-like constructor: <a href="../reference/#ImageMorphology.StructuringElements.strel_diamond"><code>strel_diamond</code></a></li><li>box-like constructor: <a href="../reference/#ImageMorphology.StructuringElements.strel_box"><code>strel_box</code></a></li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; strel_diamond((3, 3)) # immediate neighborhood: C4 connectivity</code><code class="nohighlight hljs ansi" style="display:block;">3×3 ImageMorphology.StructuringElements.SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -1:1×-1:1:
 0  1  0
 1  1  1
 0  1  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; strel_diamond((3, 3), (1, )) # along the first dimension</code><code class="nohighlight hljs ansi" style="display:block;">3×3 ImageMorphology.StructuringElements.SEDiamondArray{2, 1, UnitRange{Int64}, 1} with indices -1:1×-1:1:
 0  1  0
 0  1  0
 0  1  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; strel_box((3, 3)) # all adjacent neighborhood: C8 connectivity</code><code class="nohighlight hljs ansi" style="display:block;">3×3 ImageMorphology.StructuringElements.SEBoxArray{2, UnitRange{Int64}} with indices -1:1×-1:1:
 1  1  1
 1  1  1
 1  1  1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; strel_box((3, 3), (1, ))</code><code class="nohighlight hljs ansi" style="display:block;">3×3 ImageMorphology.StructuringElements.SEBoxArray{2, UnitRange{Int64}} with indices -1:1×-1:1:
 0  1  0
 0  1  0
 0  1  0</code></pre><p>Utilizing these constructors, we can provide an easier-to-use <code>my_erode(A, [dims])</code> interface by adding one more method:</p><pre><code class="language-julia hljs">my_erode(A, dims::Dims=ntuple(identity, ndims(A))) = my_erode(A, strel_diamond(A, dims))</code></pre><div class="admonition is-success" id="Performance-tip:-keep-the-array-type-f016f25877517510"><header class="admonition-header">Performance tip: keep the array type<a class="admonition-anchor" href="#Performance-tip:-keep-the-array-type-f016f25877517510" title="Permalink"></a></header><div class="admonition-body"><p>For the structuring element <code>Ω</code> generated from <code>strel_diamond</code> and <code>strel_box</code>, it is likely to hit a fast path if you keep its array type. For instance, <code>erode(A, strel_diamond(A))</code> is usually faster than <code>erode(A, Array(strel_diamond(A)))</code> because more information of the <code>Ω</code> shape is passed to Julia during coding and compilation.</p></div></div><h2 id="Performance-optimizations-and-the-strel_type-function"><a class="docs-heading-anchor" href="#Performance-optimizations-and-the-strel_type-function">Performance optimizations and the <code>strel_type</code> function</a><a id="Performance-optimizations-and-the-strel_type-function-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-optimizations-and-the-strel_type-function" title="Permalink"></a></h2><p>Thanks to Julia&#39;s multiple dispatch mechanism, we can provide all the optimization tricks without compromising the simple user interface. This can be programmatically done with the help of the <code>strel_type</code> function. For example, if you know a very efficient <code>erode</code> implementation for the C4 connectivity SE, then you can add it incrementally:</p><pre><code class="language-julia hljs">using ImageMorphology: MorphologySE, SEDiamond

my_erode(A, dims::Dims) = my_erode(A, strel_diamond(A, dims))
my_erode(A, Ω) = _my_erode(strel_type(Ω), A, Ω)

# the generic implementation we&#39;ve written above
function _my_erode(::MorphologySE, A, Ω)
   ...
end

# the optimized implementation for SE generated from `strel_diamond` function
function _my_erode(::SEDiamond, A, Ω)
   ...
end

# ... and other optimized versions, if there are</code></pre><p>In essence, <code>strel_type</code> is a trait function to assist the dispatch and code design:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; strel_type(Ω_mask)</code><code class="nohighlight hljs ansi" style="display:block;">ImageMorphology.StructuringElements.SEMask{2}()</code></pre><p>It returns an internal object <code>SEMask{2}()</code>. This might look scary at first glance, but it&#39;s quite a simple lookup table that reflects our previous reasoning:</p><table><tr><th style="text-align: right">representation</th><th style="text-align: right">element type</th><th style="text-align: right"><code>strel_type</code></th></tr><tr><td style="text-align: right">displacement offset</td><td style="text-align: right"><code>CartesianIndex</code></td><td style="text-align: right"><code>SEOffset</code></td></tr><tr><td style="text-align: right">connectivity mask</td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right"><code>SEMask</code></td></tr><tr><td style="text-align: right"><a href="../reference/#ImageMorphology.StructuringElements.strel_diamond"><code>strel_diamond</code></a></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right"><code>SEDiamond</code></td></tr><tr><td style="text-align: right"><a href="../reference/#ImageMorphology.StructuringElements.strel_box"><code>strel_box</code></a></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right"><code>SEBox</code></td></tr></table></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« ImageMorphology.jl</a><a class="docs-footer-nextpage" href="../operators/">Morphology Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 22 September 2025 16:44">Monday 22 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
