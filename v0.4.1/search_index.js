var documenterSearchIndex = {"docs":
[{"location":"operators/operators/extreme_filter/#op_extreme_filter","page":"extreme_filter","title":"extreme_filter","text":"","category":"section"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"The extreme_filter function is the core operation in ImageMorphology. Many other morphological operations such as dilate and erode are direct usages of it. The cover image shows a pixel jitter using random select function.","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"This page gives an overview of the extreme_filter function as a tutorial. It might not exactly show every details. For a comprehensive and more accurate documentation, please check the extreme_filter page.","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"using ImageMorphology\nusing ImageFiltering\nusing TestImages\nusing ImageBase\nusing ImageShow\nusing Random #hide\nRandom.seed!(1234); #hide\nnothing #hide","category":"page"},{"location":"operators/operators/extreme_filter/#Definition","page":"extreme_filter","title":"Definition","text":"","category":"section"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"Below is the basic interface for this function","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"extreme_filter(f, A, se)","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"For each pixel p in A, a select function f(x, y) will be applied iteratively to the its neighborhood. The neighborhood is defined by the structuring element se. In plain Julia codes, this is as simple as:","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"# For illustration purposes only; you should use `extreme_filter` in practice\nfunction simple_extreme_filter(f, A, se)\n    se = strel(CartesianIndex, se)\n    R = CartesianIndices(A)\n    for p in R\n        x = A[p]\n        for o in se\n            q = p + o\n            q in R || continue\n            x = f(x, A[q])\n        end\n        A[p] = x\n    end\nend","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"tip: structuring element\nStructuring element defines the shape of each pixel's neighborhood. If you haven't used strel before or don't know what se means. It is recommended to read the concept introduction page \"Structuring element\" first.","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"The name \"extreme\" comes from the fact that max and min are typical examples of the select function f.","category":"page"},{"location":"operators/operators/extreme_filter/#Examples","page":"extreme_filter","title":"Examples","text":"","category":"section"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"To illustrate how it works, let's load the wirebond mask image and apply the extreme filter to it.","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"img = restrict(testimage_dip3e(\"fig1005\")) # wirebond mask","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"se = strel_diamond((3, 3)) # a dimond shape structuring element","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"We use max as the select function – applying max gives the dilation operation:","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"extreme_filter(max, img, se)","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"with the SE size controls the degree of dilation:","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"imgs = [extreme_filter(max, img, strel_diamond((n, n))) for n in 3:2:13]\nmosaic(imgs; nrow=1)","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"and dims controls the dimension to be dilated:","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"img_d1 = extreme_filter(max, img, strel_diamond((13, 13), (1,)))\nimg_d2 = extreme_filter(max, img, strel_diamond((13, 13), (2,)))\nimg_d12 = extreme_filter(max, img, strel_diamond((13, 13))) # (1, 2)\nmosaic(img, img_d1, img_d2, img_d12; nrow=1)","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"The extreme_filter can be used to build many operations, including the basic dilation, erosion, and some other operators. Here we just list a few for inspiration:","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"se = strel_diamond((7, 7))\nimg_1 = extreme_filter(max, img, se) # dilate\nimg_2 = extreme_filter(min, img, se) # erode\nimg_3 = extreme_filter((x, y) -> rand() > 0.5 ? x : y, img, se) # jitter\n# or pipe the filters\nimg_4 = extreme_filter(max, extreme_filter(min, img), se) # opening\nimg_5 = extreme_filter(min, extreme_filter(max, img), se) # closing\nmosaic(img, img_1, img_2, img_3, img_4, img_5; nrow=1)","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"Many of the above operations are already implemented in ImageMorphology.","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"# the `mapwindow` function","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"There is a very similar function to extreme_filter called mapwindow(f, img, window) from ImageFiltering.jl. The main difference is that f in mapwindow applies to the entire neighborhood instead of two points in extreme_filter.","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"# currently, mapwindow only supports the box-shaped neighborhood\nimg1 = extreme_filter(max, img, strel_box((7, 7)))\nimg2 = mapwindow(maximum, img, (7, 7))\nimg1 == img2","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"","category":"page"},{"location":"operators/operators/extreme_filter/","page":"extreme_filter","title":"extreme_filter","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/overbuild/#op_overbuild","page":"overbuild","title":"overbuild","text":"","category":"section"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"overbuild is reconstruction by erosion, it is an alias for mreconstruct when op=erode.","category":"page"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\n\nimg = restrict(Gray.(testimage(\"blob\")))\nnothing # hide","category":"page"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"overbuild accepts two images as inputs: marker and mask.","category":"page"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"out = overbuild(img .- 0.2, img)\nmosaic(img, out; nrow=1)","category":"page"},{"location":"operators/operators/overbuild/#See-also","page":"overbuild","title":"See also","text":"","category":"section"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"overbuild is the dual operator of underbuild in the following sense:","category":"page"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"marker, mask = rand(32, 32), rand(32, 32)\ncomplement.(overbuild(marker, mask)) == overbuild(complement.(marker), complement.(mask))","category":"page"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"For more details, please refer to mreconstruct.","category":"page"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"","category":"page"},{"location":"operators/operators/overbuild/","page":"overbuild","title":"overbuild","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/mreconstruct/#op_mreconstruct","page":"mreconstruct","title":"mreconstruct","text":"","category":"section"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"The morphological reconstruction operator is to repeatedly apply particular operator until the stability, i.e,. output unchanged. The most widely used ones are reconstruction by dilation and reconstruction by erosion.","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\nusing IndirectArrays #hide\n\nimg = Gray.(testimage(\"blob\"))\nnothing #hide","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"Unlike other morphological operators such as erode, mreconstruct requires two image inputs. One is the marker image, and the other is the mask image. Usually, mask is the image we study on and the marker image is what we want to reconstruct from. A suitable marker image can be determined using[1]:","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"knowledge about the expected result\nknown facts about the image or the physics of the object it represents\nsome transformations of the mask image itself\nother image data, if available (i.e., multispectral and multitemporal images)\ninteraction with the user (i.e., markers are manually defined)","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"Take reconstruction by dilation as an example, we build the marker image from the mask image, then repeatedly apply marker = min.(dilate(marker), mask).","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"mask = img\nmarker = mask .- 0.3\nmosaic(marker, mask; nrow=1)","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"The following function is a naive implementation of this idea:","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"# For illustration purposes only; you should use `mreconstruct` in practice\nfunction my_reconstruct(marker, mask)\n    # reconstruction by dilation\n    # For reconstruction by erosion, one can change `min` to `max` and `dilate` to `erode`\n    out = min.(mask, marker)\n    has_changed = true\n    while has_changed\n        old = out\n        out = min.(dilate(out), mask)\n        has_changed = !(old == out)\n    end\n    return out\nend","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"The following GIF shows the intermediate result out of each iteration. The left side shows its actual gray value, and the right side shows the colored value to better visualize the progress.","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"function my_reconstruct_outs(marker, mask) #hide\n    out = min.(mask, marker) #hide\n    outs = [out] #hide\n    has_changed = true #hide\n    n = 1 #hide\n    while has_changed #hide\n        old = out #hide\n        out = min.(dilate(out), mask) #hide\n        n % 4 == 1 && push!(outs, out) #hide\n        has_changed = !(old == out) #hide\n        n = n + 1 #hide\n    end #hide\n    return outs #hide\nend #hide\nfunction with_color(img, orders, colormap) #hide\n    return IndirectArray([orders[img[i]] for i in CartesianIndices(img)], colormap) #hide\nend #hide\nouts = my_reconstruct_outs(marker, mask) #hide\norders = Dict(x => i for (i, x) in enumerate(sort(mapreduce(unique, union, outs)))) #hide\ncolormap = ImageCore.Colors.distinguishable_colors(length(orders)) #hide\ngif = ImageShow.gif([mosaic(frame, with_color(frame, orders, colormap); nrow=1) for frame in outs]; fps=5) #hide","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"This is how reconstruction happends and why it is called so – it reconstructs the marker image with a reference image mask, this helps us investigate certain properties of the mask image. For instance, if we want to investigate the blobs only (dark region), we would want to apply reconstruction by dilation to it.","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"The mreconstruct(op, marker, mask) function currently supports only dilate and erode as op, indicating reconstruction by dilation and reconstruction by erosion, respectively. There are also aliases underbuild and overbuild.","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"# reconstruction by dilation -- `underbuild`\nout1 = mreconstruct(dilate, img .- 0.3, img)\n# reconstruction by erosion -- `overbuild`\nout2 = mreconstruct(erode, img .+ 0.3, img)\nmosaic(mask, out1, out2; nrow=1)","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"The default structuring element it uses is the box-shaped SE. Like the other operators, you can pass dims keyword or positional argument se to mreconstruct. For instance,","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"mreconstruct(dilate, img .- 0.3, img; dims=1) # reconstruction along colomn\nmreconstruct(dilate, img .- 0.3, img, strel_diamond(img)) # diamond shape SE\nnothing #hide","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"However, for generic structuring element, the half-size (or, radius) should be at most 1 for each dimension. This is because the algorithm is a growing process until stability, thus SE with half-size larger than 1 doesn't make a difference in practice.","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"[1]: P. Soille, Morphological Image Analysis (Chapter 6.2.3). Berlin, Heidelberg: Springer Berlin Heidelberg, 2004. doi: 10.1007/978-3-662-05088-0.","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"","category":"page"},{"location":"operators/operators/mreconstruct/","page":"mreconstruct","title":"mreconstruct","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"using ImageMorphology\nusing ImageBase\nusing TestImages","category":"page"},{"location":"structuring_element/#concept_se","page":"Structuring element","title":"Structuring element","text":"","category":"section"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Structuring Element (SE) is the key concept in morphology to indicate the connectivity and the neighborhood. This page explains this structuring element concept, and how ImageMorphology supports the general SEs without compromising the performance on the most commonly used special SE cases.","category":"page"},{"location":"structuring_element/#The-erosion-example","page":"Structuring element","title":"The erosion example","text":"","category":"section"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"The erosion erode function in its simplest 1-dimensional case can be defined as","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"varepsilon_Ap = min(Ap-1 Ap Ap+1)","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Because the output value at position p not only depends on its own pixel A[p] but also on its neighborhood values A[p-1] and A[p+1], we call this type of operation a neighborhood image transformation.","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Now comes the question: if we try to generalize the erode function, what should we do? – we would like to generalize the concept of \"neighborhood\".","category":"page"},{"location":"structuring_element/#Two-neighborhood-representations","page":"Structuring element","title":"Two neighborhood representations","text":"","category":"section"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"By saying \"Omega_p is the neighborhood of p\", we are expressing p in Ωₚ in plain Julia. For performance consideration, this Ωₚ is usually generated from the (p, Ω) pair. p is the center point that changes during the iteration, and Ω is usually a pre-defined and unchanged data which contains the neighborhood and shape information. We call this Ω a structuring element. There are usually two ways to express Ω:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"displacement offset: a list of CartesianIndex to indicate the offset to the center point p\nconnectivity mask: a bool array mask to indicate the connectivity to the center point p","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"For instance, in the following code block we build a commonly named C4 connectivity in the 2-dimensional case:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"# displacement offset\nΩ_offsets = [\n    CartesianIndex(-1, 0),\n    CartesianIndex(0, -1),\n    CartesianIndex(0, 1),\n    CartesianIndex(1, 0),\n]\n\n# connectivity mask\nΩ_bool = Bool[\n    0 1 0\n    1 1 1\n    0 1 0\n]\nnothing #hide","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"If p=CartesianIndex(3, 3), then we know p=CartesianIndex(3, 4) is in Ωₚ.","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Now, back to the erosion example. Based on the displacement offset representation, the simplest generic version of erode can be implemented quite simply:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"# For illustration only, performance can be greatly improved using iteration to eliminate allocations\nfunction my_erode(A, Ω)\n    out = similar(A)\n    R = CartesianIndices(A)\n    for p in R\n        Ωₚ = filter!(q->in(q, R), Ref(p) .+ Ω)\n        # here we don't assume p in Ωₚ\n        out[p] = min(A[p], minimum(A[Ωₚ]))\n    end\n    return out\nend\nnothing #hide","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"using ImageMorphology\nusing ImageBase\nusing TestImages\n\nimg = Gray.(testimage(\"morphology_test_512\"))\nimg = Gray.(img .< 0.8)\nimg_e = my_erode(img, Ω_offsets)\nmosaic(img, img_e; nrow=1)","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"As you may realize, the displacement offset representation is convenient to use when implementing algorithms, but it is hard to visualize. In contrast, the connectivity mask is not so convenient to use when implementing algorithms, but it is easy to visualize. For instance, one can very easily understand the following SE at the first glance:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Ω = Bool[1 1 1; 1 1 0; 0 0 0] # hide","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"but not","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"strel(CartesianIndex, Ω) # hide","category":"page"},{"location":"structuring_element/#The-strel-function","page":"Structuring element","title":"The strel function","text":"","category":"section"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"This package supports the conversion between different SE representations via the strel helper function. strel is the short name for \"STRucturing ELement\".","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"To convert a connectivity mask representation to displacement offset representation:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Ω_mask = Bool[1 1 1; 1 1 0; 0 0 0] |> centered\nΩ_offsets = strel(CartesianIndex, Ω_mask)","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"note: zero-centered mask\nThe mask array is expected to be zero-centered. That means, the axes of a 3×3 mask axes(se) should be (-1:1, -1:1). The centered function is used to shift the center point of the array to (0, 0, ..., 0).julia> A = centered([1 2 3; 4 5 6; 7 8 9])\n3×3 OffsetArray(::Matrix{Int64}, -1:1, -1:1) with eltype Int64 with indices -1:1×-1:1:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> A[-1, -1], A[0, 0], A[1, 1] # top-left, center, bottom-right\n(1, 5, 9)This centered function comes from OffsetArrays.jl and is also exported by ImageMorphology.","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"And to convert back from a displacement offset representation to connectivity mask representation:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"strel(Bool, Ω_offsets)","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Quite simple, right? Thus to make our my_erode function more generic, we only need to add one single line:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":" function my_erode(A, Ω)\n     out = similar(A)\n+    Ω = strel(CartesianIndex, Ω)\n     R = CartesianIndices(A)","category":"page"},{"location":"structuring_element/#concept_symmetric","page":"Structuring element","title":"Symmetricity","text":"","category":"section"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Among all the structuring elements, the symmetric ones are used most in practice – they have better properties and their symmetry enables certain implementation optimizations.","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"The SE symmetricity is defined with respect to the center point for the mask representation mask = strel(Bool, se): se is symmetric if mask[I] == mask[-I] holds for I ∈ CartesianIndices(mask). – This is also why mask representation requires a centered array.","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"se = centered(Bool[\n    1 0 1\n    0 1 0\n    1 0 1\n])\nImageMorphology.is_symmetric(se) # true\n\nse = centered(Bool[\n    1 1 1\n    0 1 0\n    1 0 1\n])\nImageMorphology.is_symmetric(se) # false\n\nse = [CartesianIndex(1), CartesianIndex(-1)]\nImageMorphology.is_symmetric(se) # true\n\nse = [CartesianIndex(1)]\nImageMorphology.is_symmetric(se) # false\nnothing #hide","category":"page"},{"location":"structuring_element/#Convenient-constructors","page":"Structuring element","title":"Convenient constructors","text":"","category":"section"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Among all the SE possibilities, this package provides constructors for two commonly used cases:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"diamond-like constructor: strel_diamond\nbox-like constructor: strel_box","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"strel_diamond((3, 3)) # immediate neighborhood: C4 connectivity\nstrel_diamond((3, 3), (1, )) # along the first dimension\nstrel_box((3, 3)) # all adjacent neighborhood: C8 connectivity\nstrel_box((3, 3), (1, ))","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Utilizing these constructors, we can provide an easier-to-use my_erode(A, [dims]) interface by adding one more method:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"my_erode(A, dims::Dims=ntuple(identity, ndims(A))) = my_erode(A, strel_diamond(A, dims))","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"tip: Performance tip: keep the array type\nFor the structuring element Ω generated from strel_diamond and strel_box, it is likely to hit a fast path if you keep its array type. For instance, erode(A, strel_diamond(A)) is usually faster than erode(A, Array(strel_diamond(A))) because more information of the Ω shape is passed to Julia during coding and compilation.","category":"page"},{"location":"structuring_element/#Performance-optimizations-and-the-strel_type-function","page":"Structuring element","title":"Performance optimizations and the strel_type function","text":"","category":"section"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"Thanks to Julia's multiple dispatch mechanism, we can provide all the optimization tricks without compromising the simple user interface. This can be programmatically done with the help of the strel_type function. For example, if you know a very efficient erode implementation for the C4 connectivity SE, then you can add it incrementally:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"using ImageMorphology: MorphologySE, SEDiamond\n\nmy_erode(A, dims::Dims) = my_erode(A, strel_diamond(A, dims))\nmy_erode(A, Ω) = _my_erode(strel_type(Ω), A, Ω)\n\n# the generic implementation we've written above\nfunction _my_erode(::MorphologySE, A, Ω)\n   ...\nend\n\n# the optimized implementation for SE generated from `strel_diamond` function\nfunction _my_erode(::SEDiamond, A, Ω)\n   ...\nend\n\n# ... and other optimized versions, if there are","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"In essence, strel_type is a trait function to assist the dispatch and code design:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"strel_type(Ω_mask)","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"It returns an internal object SEMask{2}(). This might look scary at first glance, but it's quite a simple lookup table that reflects our previous reasoning:","category":"page"},{"location":"structuring_element/","page":"Structuring element","title":"Structuring element","text":"representation element type strel_type\ndisplacement offset CartesianIndex SEOffset\nconnectivity mask Bool SEMask\nstrel_diamond Bool SEDiamond\nstrel_box Bool SEBox","category":"page"},{"location":"operators/operators/tophat/#op_tophat","page":"tophat","title":"tophat","text":"","category":"section"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"The (white) tophat operator is defined as img - opening(img). Intuitively, this filter can be used to extract small white elements and details from an image.","category":"page"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow","category":"page"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"img = restrict(testimage_dip3e(\"fig1005\")) # wirebond mask\n\nout1 = tophat(img) # default: all spatial dimensions, r=1, a box-shape SE\nout2 = tophat(img; dims=(2,)) # only apply to the second dimension\nout3 = tophat(img; r=5) # half-size r=5\nout4 = tophat(img, strel_diamond((5, 5))) # generic SE -- this version doesn't accept `r` and `dims`\n\nmosaic(img, out1, out2, out3, out4; nrow=1)","category":"page"},{"location":"operators/operators/tophat/#See-also","page":"tophat","title":"See also","text":"","category":"section"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"To extract black small details, use bothat.","category":"page"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"bothat(img) == tophat(complement.(img))","category":"page"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"For a comprehensive and more accurate documentation, please check the tophat reference page.","category":"page"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"","category":"page"},{"location":"operators/operators/tophat/","page":"tophat","title":"tophat","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/closing/#op_closing","page":"closing","title":"closing","text":"","category":"section"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"closing operator is defined as dilate(erode(img)). Intuitively, closing operation fills the black holes in the image.","category":"page"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\n\nimg = restrict(testimage_dip3e(\"fig0940\")) # rice\nimg01 = @. Gray(img > 0.5)\nmosaic(img, img01; nrow=1)","category":"page"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"out1 = closing(img) # default: all spatial dimensions, r=1, a box-shape SE\nout2 = closing(img; dims=(2,)) # only apply to the second dimension\nout3 = closing(img; r=5) # half-size r=5\n\n# also to the binary version\nout1_01 = closing(img01)\nout2_01 = closing(img01; dims=(2,))\nout3_01 = closing(img01; r=5)\n\nmosaic(out1, out2, out3, out1_01, out2_01, out3_01; nrow=2, rowmajor=true)","category":"page"},{"location":"operators/operators/closing/#See-also","page":"closing","title":"See also","text":"","category":"section"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"closing is the dual operator of closing in the following sense:","category":"page"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"complement.(closing(img)) == closing(complement.(img))","category":"page"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"For a comprehensive and more accurate documentation, please check the closing reference page.","category":"page"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"","category":"page"},{"location":"operators/operators/closing/","page":"closing","title":"closing","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/opening/#op_opening","page":"opening","title":"opening","text":"","category":"section"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"opening operator is defined as dilate(erode(img)). Intuitively, opening operation fills the white holes in the image.","category":"page"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\n\nimg = restrict(testimage_dip3e(\"fig0940\")) # rice\nimg01 = @. Gray(img > 0.5)\nmosaic(img, img01; nrow=1)","category":"page"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"out1 = opening(img) # default: all spatial dimensions, r=1, a box-shape SE\nout2 = opening(img; dims=(2,)) # only apply to the second dimension\nout3 = opening(img; r=5) # half-size r=5\n\n# also to the binary version\nout1_01 = opening(img01)\nout2_01 = opening(img01; dims=(2,))\nout3_01 = opening(img01; r=5)\n\nmosaic(out1, out2, out3, out1_01, out2_01, out3_01; nrow=2, rowmajor=true)","category":"page"},{"location":"operators/operators/opening/#See-also","page":"opening","title":"See also","text":"","category":"section"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"closing is the dual operator of opening in the following sense:","category":"page"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"complement.(opening(img)) == closing(complement.(img))","category":"page"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"For a comprehensive and more accurate documentation, please check the opening reference page.","category":"page"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"","category":"page"},{"location":"operators/operators/opening/","page":"opening","title":"opening","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/erode/#op_erode","page":"erode","title":"erode","text":"","category":"section"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"The dilation operator erode is essentially a min filter. This is a basic term in mathematical morphology – many operations are built on top of erode and the dilate operator.","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\n\nimg = restrict(testimage_dip3e(\"fig1005\")) # wirebond mask","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"For each pixel, dilation is the minimum of the pixels in the neighborhood. In mathematics, erode(A, Ω) is defined as delta_Ap = infAp+o  o in Omega where Ω is the structuring element.","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"The simplest usage is erode(img; [dims], [r]), where dims and r controls the neighborhood shape.","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"out1 = erode(img) # default: all spatial dimensions, r=1, a box-shape SE\nout2 = erode(img; dims=(2,)) # only apply to the second dimension\nout3 = erode(img; r=5) # half-size r=5\nmosaic(out1, out2, out3; nrow=1)","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"It uses the strel_box to create a box-shaped structuring element. You can also provide a custom SE via the erode(img, se) interface.","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"out1 = erode(img, strel_box((3, 3))) # default se for`erode(img)`\nse = centered(Bool[1 1 1; 1 1 0; 0 0 0]) # match top-left region\nout2 = erode(img, se)\nmosaic(out1, out2; nrow=1)","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"An in-place version erode! is also provided, for instance","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"out1 = similar(img)\nerode!(out1, img)\n\nout2 = similar(img)\nerode!(out2, img, strel_diamond((3, 3)))\nnothing #hide","category":"page"},{"location":"operators/operators/erode/#See-also","page":"erode","title":"See also","text":"","category":"section"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"erode is the dual operator of dilate in the following sense:","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"complement.(erode(img)) == erode(complement.(img))","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"For bool arrays and symmetric SEs, erosion becomes equivalent to the minkowski difference on sets: A ominus B =  a-b  a in A b in B .","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"For a comprehensive and more accurate documentation, please check the erode reference page.","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"","category":"page"},{"location":"operators/operators/erode/","page":"erode","title":"erode","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/underbuild/#op_underbuild","page":"underbuild","title":"underbuild","text":"","category":"section"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"underbuild is reconstruction by dilation, it is an alias for mreconstruct when op=dilate.","category":"page"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\n\nimg = restrict(Gray.(testimage(\"blob\")))\nnothing # hide","category":"page"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"underbuild accepts two images as inputs: marker and mask.","category":"page"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"out = underbuild(img .- 0.2, img)\nmosaic(img, out; nrow=1)","category":"page"},{"location":"operators/operators/underbuild/#See-also","page":"underbuild","title":"See also","text":"","category":"section"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"underbuild is the dual operator of overbuild in the following sense:","category":"page"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"marker, mask = rand(32, 32), rand(32, 32)\ncomplement.(underbuild(marker, mask)) == underbuild(complement.(marker), complement.(mask))","category":"page"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"For more details, please refer to mreconstruct.","category":"page"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"","category":"page"},{"location":"operators/operators/underbuild/","page":"underbuild","title":"underbuild","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/bothat/#op_bothat","page":"bothat","title":"bothat","text":"","category":"section"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"The (black) tophat operator, also known as bottom hat, is defined as closing(img) - img. Intuitively, this filter can be used to extract small black elements and details from an image.","category":"page"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow","category":"page"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"img = restrict(testimage_dip3e(\"fig1038\")) # fingerprint\n\nout1 = bothat(img) # default: all spatial dimensions, r=1, a box-shape SE\nout2 = bothat(img; dims=(2,)) # only apply to the second dimension\nout3 = bothat(img; r=5) # half-size r=5\nout4 = bothat(img, strel_diamond((5, 5))) # generic SE -- this version doesn't accept `r` and `dims`\n\nmosaic(img, out1, out2, out3, out4; nrow=1)","category":"page"},{"location":"operators/operators/bothat/#See-also","page":"bothat","title":"See also","text":"","category":"section"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"To extract white small details, use the white tophat:","category":"page"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"tophat(img) == bothat(complement.(img))","category":"page"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"For a comprehensive and more accurate documentation, please check the bothat reference page.","category":"page"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"","category":"page"},{"location":"operators/operators/bothat/","page":"bothat","title":"bothat","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/mgradient/#op_mgradient","page":"mgradient","title":"mgradient","text":"","category":"section"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"There are three commonly used morphological gradient definitions: the beucher gradident dilate(img) - erode(img), the external half-gradient dilate(img) - img, and the internal half-gradident img - erode(img).","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\n\nimg = restrict(testimage_dip3e(\"fig0940\")) # rice\nimg01 = @. Gray(img > 0.5)\nmosaic(img, img01; nrow=1)","category":"page"},{"location":"operators/operators/mgradient/#Beucher-gradient","page":"mgradient","title":"Beucher gradient","text":"","category":"section"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"The default mode is beucher gradient defined as dilate(img) - erode(img).","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"mosaic(mgradient(img), mgradient(img01); nrow=1)","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"There are two nice properties of the beucher gradient:","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"it is always positive if the structuring element is symmetric\nit is a self-complementary operator – mgradient(img) == mgradient(complement.(img))","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"all(mgradient(rand(32, 32)) .> 0) # always positive","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"A = rand(32, 32)\nmgradient(A) == mgradient(1 .- A) # self-complementary","category":"page"},{"location":"operators/operators/mgradient/#Half-gradient","page":"mgradient","title":"Half gradient","text":"","category":"section"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"If we look closely, we can see that the beucher gradient boundary is always two-pixel wide – one pixel per each side.","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"A = falses(7, 7)\nA[3:5, 3:5] .= true\nA","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"Int.(mgradient(A))","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"This is because dilate extends the boundary for one pixel, while erode shrinks for one pixel. This observation introduces so-called half-gradients.","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"The external half-gradient, also known as half-gradient by dilation, is defined as dilate(img) - img:","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"Int.(mgradient(A; mode=:external)) # external boundary","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"The internal half-gradient, also known as half-gradient by erosion, is defined as img - erode(img):","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"Int.(mgradient(A; mode=:internal)) # internal boundary","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"Note that the result of internal gradient is inside the original image, and that of external gradient is outside the original image. Also, external gradient and internal are complementary to each other:","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"A = rand(32, 32)\nmgradient(A; mode=:external) == mgradient(1 .- A; mode=:internal)","category":"page"},{"location":"operators/operators/mgradient/#Thick-gradient","page":"mgradient","title":"Thick gradient","text":"","category":"section"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"The gradient thickness is controlled by the SE size, or the r parameter. When r>1, it is usually called thick gradient.","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"mosaic([mgradient(img01; r) for r in 1:3]; nrow=1)","category":"page"},{"location":"operators/operators/mgradient/#See-also","page":"mgradient","title":"See also","text":"","category":"section"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"There are many useful gradient definitions in image processing. For instance, ImageBase.jl provides the finite-difference version of gradients fdiff and fgradient. ImageFiltering.jl provides sobel, prewitt and other gradient filters.","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"fout = abs.(ImageBase.FiniteDiff.fdiff(img; dims=1))\nmout = mgradient(img; dims=1)\nmosaic(fout, mout; nrow=1)","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"For a comprehensive and more accurate documentation, please check the mgradient reference page.","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"","category":"page"},{"location":"operators/operators/mgradient/","page":"mgradient","title":"mgradient","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"reference/#reference_index","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#reference_se","page":"Reference","title":"Structuring element","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"# conversion\nstrel\n\n# constructor\nstrel_chain\nstrel_product\nstrel_box\nstrel_diamond\n\n# helpers\nstrel_type\nstrel_size\nImageMorphology.StructuringElements.strel_ndims\nImageMorphology.StructuringElements.strel_split\nOffsetArrays.centered\nOffsetArrays.center\n\nImageMorphology.StructuringElements.is_symmetric\n\n## types\nImageMorphology.StructuringElements.SEMask\nImageMorphology.StructuringElements.SEOffset\nImageMorphology.StructuringElements.SEDiamond\nImageMorphology.StructuringElements.SEBox\nImageMorphology.StructuringElements.SEDiamondArray\nImageMorphology.StructuringElements.SEBoxArray","category":"page"},{"location":"reference/#ImageMorphology.StructuringElements.strel","page":"Reference","title":"ImageMorphology.StructuringElements.strel","text":"strel([T], X::AbstractArray)\n\nConvert structuring element (SE) X to appropriate presentation format with element type T. This is a useful tool to generate SE that most ImageMorphology functions understand.\n\nImageMorphology currently supports two commonly used representations:\n\nT=CartesianIndex: offsets to its center point. The output type is Vector{CartesianIndex{N}}.\nT=Bool: connectivity mask where true indicates connected to its center point. The output type is BitArray{N}.\n\njulia> se_mask = centered(Bool[1 1 0; 1 1 0; 0 0 0]) # connectivity mask\n3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 1  1  0\n 1  1  0\n 0  0  0\n\njulia> se_offsets = strel(CartesianIndex, se_mask) # displacement offsets to its center point\n3-element Vector{CartesianIndex{2}}:\n CartesianIndex(-1, -1)\n CartesianIndex(0, -1)\n CartesianIndex(-1, 0)\n\njulia> se = strel(Bool, se_offsets)\n3×3 OffsetArray(::BitMatrix, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 1  1  0\n 1  1  0\n 0  0  0\n\nSee also strel_diamond and strel_box for SE constructors for two special cases.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.strel_chain","page":"Reference","title":"ImageMorphology.StructuringElements.strel_chain","text":"strel_chain(A, B, ...)\nstrel_chain(As)\n\nFor structuring elements of the same dimensions, chain them together to build a bigger one.\n\nThe output dimension is the same as the inputs dimensions. See also strel_product that cartesian producting each SE.\n\nnote: structuring element decomposition\nFor some morphological operations f such as dilation and erosion, if se can be decomposed into smaller ones se1, se2, ..., seN, then f(img, se) is equivalent to f(...f(f(img, se1), se2), ..., seN). Because applying f to smaller SEs is more efficient than to the original big one, this trick is used widely in image morphology.\n\njulia> img = rand(512, 512);\n\njulia> se1, se2 = [centered(rand(Bool, 3, 3)) for _ in 1:2];\n\njulia> se = strel_chain(se1, se2);\n\njulia> out_se = dilate(img, se);\n\njulia> out_pipe = dilate(dilate(img, se1), se2);\n\njulia> out_se[2:end-1, 2:end-1] == out_pipe[2:end-1, 2:end-1] # except for the boundary\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.strel_product","page":"Reference","title":"ImageMorphology.StructuringElements.strel_product","text":"strel_product(A, B, ...)\nstrel_product(se_list)\n\nCartesian product of multiple structuring elements; the output dimension ndims(out) == sum(ndims, se_list).\n\nSee also strel_chain that chains SEs in the same dimension.\n\njulia> strel_product(strel_diamond((5, 5)), centered(Bool[1, 1, 1]))\n5×5×3 SEChainArray{3, OffsetArrays.OffsetArray{Bool, 3, BitArray{3}}} with indices -2:2×-2:2×-1:1:\n[:, :, -1] =\n 0  0  1  0  0\n 0  1  1  1  0\n 1  1  1  1  1\n 0  1  1  1  0\n 0  0  1  0  0\n\n[:, :, 0] =\n 0  0  1  0  0\n 0  1  1  1  0\n 1  1  1  1  1\n 0  1  1  1  0\n 0  0  1  0  0\n\n[:, :, 1] =\n 0  0  1  0  0\n 0  1  1  1  0\n 1  1  1  1  1\n 0  1  1  1  0\n 0  0  1  0  0\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.strel_box","page":"Reference","title":"ImageMorphology.StructuringElements.strel_box","text":"strel_box(A; r=1)\nstrel_box(size; r=size .÷ 2)\n\nConstruct the N-dimensional structuring element (SE) with all elements in the local window connected.\n\nIf image A is provided, then the SE size will be (2r+1, 2r+1, ...) with default half-size r=1. If size is provided, the default r will be size .÷ 2. The default dims will be all dimensions, that is, (1, 2, ..., length(size)).\n\njulia> img = rand(64, 64);\n\njulia> strel_box(img)\n3×3 SEBoxArray{2, UnitRange{Int64}} with indices -1:1×-1:1:\n 1  1  1\n 1  1  1\n 1  1  1\n\njulia> strel_box(img; r=2)\n5×5 SEBoxArray{2, UnitRange{Int64}} with indices -2:2×-2:2:\n 1  1  1  1  1\n 1  1  1  1  1\n 1  1  1  1  1\n 1  1  1  1  1\n 1  1  1  1  1\n\njulia> strel_box((5,5); r=(1,2))\n5×5 SEBoxArray{2, UnitRange{Int64}} with indices -2:2×-2:2:\n 0  0  0  0  0\n 1  1  1  1  1\n 1  1  1  1  1\n 1  1  1  1  1\n 0  0  0  0  0\n\nnote: specialization and performance\nThe box shape SEBox is a special type for which many morphology algorithms may provide efficient implementations. For this reason, if one tries to collect an SEBoxArray into other array types (e.g. Array{Bool} via collect), then a significant performance drop is very likely to occur.\n\nSee also strel and strel_box.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.strel_diamond","page":"Reference","title":"ImageMorphology.StructuringElements.strel_diamond","text":"strel_diamond(A::AbstractArray, [dims]; r=1)\nstrel_diamond(size, [dims]; [r])\n\nConstruct the N-dimensional structuring element (SE) for a diamond shape.\n\nIf image A is provided, then the SE size will be (2r+1, 2r+1, ...) with default half-size r=1. If size is provided, the default r will be maximum(size)÷2. The default dims will be all dimensions, that is, (1, 2, ..., length(size)).\n\njulia> img = rand(64, 64);\n\njulia> strel_diamond(img) # default size for image input is (3, 3)\n3×3 SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -1:1×-1:1:\n 0  1  0\n 1  1  1\n 0  1  0\n\njulia> strel_diamond(img; r=2) # equivalent to `strel_diamond((5,5))`\n5×5 SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -2:2×-2:2:\n 0  0  1  0  0\n 0  1  1  1  0\n 1  1  1  1  1\n 0  1  1  1  0\n 0  0  1  0  0\n\njulia> strel_diamond(img, (1,)) # mask along dimension 1\n3×1 SEDiamondArray{2, 1, UnitRange{Int64}, 1} with indices -1:1×0:0:\n 1\n 1\n 1\n\njulia> strel_diamond((3,3), (1,)) # 3×3 mask along dimension 1\n3×3 SEDiamondArray{2, 1, UnitRange{Int64}, 1} with indices -1:1×-1:1:\n 0  1  0\n 0  1  0\n 0  1  0\n\nnote: specialization and performance\nThe diamond shape SEDiamond is a special type for which many morphology algorithms may provide much more efficient implementations. For this reason, if one tries to collect an SEDiamondArray into other array types (e.g. Array{Bool} via collect), then a significant performance drop is very likely to occur.\n\nSee also strel and strel_box.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.strel_type","page":"Reference","title":"ImageMorphology.StructuringElements.strel_type","text":"strel_type(x)\n\nInfer the structuring element type for x.\n\nnote: developer note\nThis function is used to dispatch special SE types, e.g., SEBoxArray, to optimized implementation of particular morphology filter. In this sense it is required for custom SE array types to define this method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.strel_size","page":"Reference","title":"ImageMorphology.StructuringElements.strel_size","text":"strel_size(x)\n\nCalculate the minimal block size that contains the structuring element. The result will be a tuple of odd integers.\n\njulia> se = strel_diamond((5, 5); r=1)\n5×5 SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -2:2×-2:2:\n 0  0  0  0  0\n 0  0  1  0  0\n 0  1  1  1  0\n 0  0  1  0  0\n 0  0  0  0  0\n\njulia> strel_size(se) # is not (5, 5)\n(3, 3)\n\njulia> strel(Bool, strel(CartesianIndex, se)) # because it only checks the minimal enclosing block\n3×3 OffsetArray(::BitMatrix, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 0  1  0\n 1  1  1\n 0  1  0\n\njulia> se = [CartesianIndex(1, 1), CartesianIndex(-2, -2)];\n\njulia> strel_size(se) # is not (4, 4)\n(5, 5)\n\njulia> strel(Bool, se) # because the connectivity mask has to be odd size\n5×5 OffsetArray(::BitMatrix, -2:2, -2:2) with eltype Bool with indices -2:2×-2:2:\n 1  0  0  0  0\n 0  0  0  0  0\n 0  0  1  0  0\n 0  0  0  1  0\n 0  0  0  0  0\n\njulia> se = strel_diamond((5, 5), (1, ); r=1)\n5×5 SEDiamondArray{2, 1, UnitRange{Int64}, 1} with indices -2:2×-2:2:\n 0  0  0  0  0\n 0  0  1  0  0\n 0  0  1  0  0\n 0  0  1  0  0\n 0  0  0  0  0\n\njulia> strel_size(se)\n(3, 1)\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.strel_ndims","page":"Reference","title":"ImageMorphology.StructuringElements.strel_ndims","text":"strel_ndims(x)::Int\n\nInfer the dimension of the structuring element x\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.strel_split","page":"Reference","title":"ImageMorphology.StructuringElements.strel_split","text":"upper, lower = strel_split([T], se)\n\nSplit a symmetric structuring element into its upper and lower half parts based on its center point.\n\nFor each element o in strel(CartesianIndex, upper), its negative -o is an element of strel(CartesianIndex, lower). This function is not the inverse of strel_chain.\n\nThe splited non-symmetric SE parts will be represented as array of T, where T is either a Bool or CartesianIndex. By default, T = eltype(se).\n\njulia> se = strel_diamond((3, 3))\n3×3 SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -1:1×-1:1:\n 0  1  0\n 1  1  1\n 0  1  0\n\njulia> upper, lower = strel_split(se);\n\njulia> upper\n3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 0  1  0\n 1  1  0\n 0  0  0\n\njulia> lower\n3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 0  0  0\n 0  1  1\n 0  1  0\n\nIf the se is represented as displacement offset array, then the splited result will also be displacement offset array:\n\njulia> se = strel(CartesianIndex, se)\n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(0, -1)\n CartesianIndex(-1, 0)\n CartesianIndex(1, 0)\n CartesianIndex(0, 1)\n\njulia> upper, lower = strel_split(se);\n\njulia> upper\n2-element Vector{CartesianIndex{2}}:\n CartesianIndex(0, -1)\n CartesianIndex(-1, 0)\n\njulia> lower\n2-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 0)\n CartesianIndex(0, 1)\n\n\n\n\n\n","category":"function"},{"location":"reference/#OffsetArrays.centered","page":"Reference","title":"OffsetArrays.centered","text":"centered(A, cp=center(A)) -> Ao\n\nShift the center coordinate/point cp of array A to (0, 0, ..., 0). Internally, this is equivalent to OffsetArray(A, .-cp).\n\ncompat: OffsetArrays 1.9\nThis method requires at least OffsetArrays 1.9.\n\nExamples\n\njulia> A = reshape(collect(1:9), 3, 3)\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> Ao = OffsetArrays.centered(A); # axes (-1:1, -1:1)\n\njulia> Ao[0, 0]\n5\n\njulia> Ao = OffsetArray(A, OffsetArrays.Origin(0)); # axes (0:2, 0:2)\n\njulia> Aoo = OffsetArrays.centered(Ao); # axes (-1:1, -1:1)\n\njulia> Aoo[0, 0]\n5\n\nUsers are allowed to pass cp to change how \"center point\" is interpreted, but the meaning of the output array should be reinterpreted as well. For instance, if cp = map(last, axes(A)) then this function no longer shifts the center point but instead the bottom-right point to (0, 0, ..., 0). A commonly usage of cp is to change the rounding behavior when the array is of even size at some dimension:\n\njulia> A = reshape(collect(1:4), 2, 2) # Ideally the center should be (1.5, 1.5) but OffsetArrays only support integer offsets\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> OffsetArrays.centered(A, OffsetArrays.center(A, RoundUp)) # set (2, 2) as the center point\n2×2 OffsetArray(::Matrix{Int64}, -1:0, -1:0) with eltype Int64 with indices -1:0×-1:0:\n 1  3\n 2  4\n\njulia> OffsetArrays.centered(A, OffsetArrays.center(A, RoundDown)) # set (1, 1) as the center point\n2×2 OffsetArray(::Matrix{Int64}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:\n 1  3\n 2  4\n\nSee also center.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OffsetArrays.center","page":"Reference","title":"OffsetArrays.center","text":"center(A, [r::RoundingMode=RoundDown])::Dims\n\nReturn the center coordinate of given array A. If size(A, k) is even, a rounding procedure will be applied with mode r.\n\ncompat: OffsetArrays 1.9\nThis method requires at least OffsetArrays 1.9.\n\nExamples\n\njulia> A = reshape(collect(1:9), 3, 3)\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> c = OffsetArrays.center(A)\n(2, 2)\n\njulia> A[c...]\n5\n\njulia> Ao = OffsetArray(A, -2, -2); # axes (-1:1, -1:1)\n\njulia> c = OffsetArrays.center(Ao)\n(0, 0)\n\njulia> Ao[c...]\n5\n\nTo shift the center coordinate of the given array to (0, 0, ...), you can use centered.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.is_symmetric","page":"Reference","title":"ImageMorphology.StructuringElements.is_symmetric","text":"is_symmetric(se)\n\nCheck if a given structuring element array se is symmetric with respect to its center pixel.\n\nMore formally, this checks if mask[I] == mask[-I] for any valid I ∈ CartesianIndices(mask) in the connectivity mask represetation mask = strel(Bool, se).\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.StructuringElements.SEMask","page":"Reference","title":"ImageMorphology.StructuringElements.SEMask","text":"SEMask{N}()\n\nA (holy) trait type for representing structuring element as connectivity mask. This connectivity mask SE is a bool array where true indicates that pixel position is connected to the center point.\n\njulia> se = centered(Bool[0 1 0; 1 1 1; 0 1 0]) # commonly known as C4 connectivity\n3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 0  1  0\n 1  1  1\n 0  1  0\n\njulia> strel_type(se)\nImageMorphology.StructuringElements.SEMask{2}()\n\nSee also SEOffset for the displacement offset representation. More details can be found on he documentation page Structuring Element.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageMorphology.StructuringElements.SEOffset","page":"Reference","title":"ImageMorphology.StructuringElements.SEOffset","text":"SEOffset{N}()\n\nA (holy) trait type for representing structuring element as displacement offsets. This displacement offsets SE is an array of CartesianIndex where each element stores the displacement offset from the center point.\n\njulia> se = [CartesianIndex(-1, 0), CartesianIndex(0, -1), CartesianIndex(1, 0), CartesianIndex(0, 1)]\n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(-1, 0)\n CartesianIndex(0, -1)\n CartesianIndex(1, 0)\n CartesianIndex(0, 1)\n\njulia> strel_type(se)\nImageMorphology.StructuringElements.SEOffset{2}()\n\nSee also SEMask for the connectivity mask representation. More details can be found on he documentation page Structuring Element.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageMorphology.StructuringElements.SEDiamond","page":"Reference","title":"ImageMorphology.StructuringElements.SEDiamond","text":"SEDiamond{N}(axes, [dims]; [r])\n\nA (holy) trait type for the N-dimensional diamond shape structuring element. This is a special case of SEMask that ImageMorphology algorithms might provide optimized implementation.\n\nIt is recommended to use strel_diamond and strel_type:\n\njulia> se = strel_diamond((3, 3)) # C4 connectivity\n3×3 SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -1:1×-1:1:\n 0  1  0\n 1  1  1\n 0  1  0\n\njulia> strel_type(se)\nSEDiamond{2, 2, UnitRange{Int64}}((-1:1, -1:1), (1, 2), 1)\n\njulia> se = centered(collect(se)) # converted to normal centered array\n3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 0  1  0\n 1  1  1\n 0  1  0\n\njulia> strel_type(se)\nSEMask{2}()\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageMorphology.StructuringElements.SEBox","page":"Reference","title":"ImageMorphology.StructuringElements.SEBox","text":"SEBox{N}(axes; [r])\n\nThe N-dimensional structuring element with all elements connected. This is a special case of SEMask that ImageMorphology algorithms might provide optimized implementation.\n\nIt is recommended to use strel_box and strel_type:\n\njulia> se = strel_box((3, 3)) # C8 connectivity\n3×3 SEBoxArray{2, UnitRange{Int64}} with indices -1:1×-1:1:\n 1  1  1\n 1  1  1\n 1  1  1\n\njulia> strel_type(se)\nSEBox{2, UnitRange{Int64}}((-1:1, -1:1), (1, 1))\n\njulia> se = centered(collect(se)) # converted to normal centered array\n3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 1  1  1\n 1  1  1\n 1  1  1\n\njulia> strel_type(se)\nSEMask{2}()\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageMorphology.StructuringElements.SEDiamondArray","page":"Reference","title":"ImageMorphology.StructuringElements.SEDiamondArray","text":"SEDiamondArray(se::SEDiamond)\n\nThe instantiated array object of SEDiamond.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageMorphology.StructuringElements.SEBoxArray","page":"Reference","title":"ImageMorphology.StructuringElements.SEBoxArray","text":"SEBoxArray(se::SEBox)\n\nThe instantiated array object of SEBox.\n\n\n\n\n\n","category":"type"},{"location":"reference/#reference_ops","page":"Reference","title":"Morphological operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"extreme_filter\nextreme_filter!\ndilate\ndilate!\nerode\nerode!\nopening\nopening!\nclosing\nclosing!\ntophat\ntophat!\nbothat\nbothat!\nmgradient\nmgradient!\nmlaplacian\nmlaplacian!","category":"page"},{"location":"reference/#ImageMorphology.extreme_filter","page":"Reference","title":"ImageMorphology.extreme_filter","text":"extreme_filter(f, A; r=1, [dims]) -> out\nextreme_filter(f, A, Ω) -> out\n\nFilter the array A using select function f(x, y) for each Ω-neighborhood. The name \"extreme\" comes from the fact that typical select function f choice is min and max.\n\nFor each pixel p in A, the select function f is applied to its Ω-neighborhood iteratively in a f(...(f(f(A[p], A[p+Ω[1]]), A[p+Ω[2]]), ...) manner. For instance, in the 1-dimensional case, out[p] = f(f(A[p], A[p-1]), A[p+1]) for each p is the default behavior.\n\nThe Ω-neighborhood is defined by the dims or Ω argument. The r and dims keywords specifies the box shape neighborhood Ω using strel_box. The Ω is also known as structuring element (SE), it can be either displacement offsets or bool array mask, please refer to strel for more details.\n\nExamples\n\njulia> M = [4 6 5 3 4; 8 6 9 4 8; 7 8 4 9 6; 6 2 2 1 7; 1 6 5 2 6]\n5×5 Matrix{Int64}:\n 4  6  5  3  4\n 8  6  9  4  8\n 7  8  4  9  6\n 6  2  2  1  7\n 1  6  5  2  6\n\njulia> extreme_filter(max, M) # max-filter using 4 direct neighbors along both dimensions\n5×5 Matrix{Int64}:\n 8  9  9  9  8\n 8  9  9  9  9\n 8  9  9  9  9\n 8  8  9  9  9\n 6  6  6  7  7\n\njulia> extreme_filter(max, M; dims=1) # max-filter along the first dimension (column)\n5×5 Matrix{Int64}:\n 8  6  9  4  8\n 8  8  9  9  8\n 8  8  9  9  8\n 7  8  5  9  7\n 6  6  5  2  7\n\nΩ can be either an AbstractArray{Bool} mask array with true element indicating connectivity, or a AbstractArray{<:CartesianIndex} array with each element indicating the displacement offset to its center element.\n\njulia> Ω_mask = centered(Bool[1 1 0; 1 1 0; 1 0 0]) # custom neighborhood in mask format\n3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:\n 1  1  0\n 1  1  0\n 1  0  0\n\njulia> out = extreme_filter(max, M, Ω_mask)\n5×5 Matrix{Int64}:\n 4  8  6  9  4\n 8  8  9  9  9\n 8  8  9  9  9\n 7  8  8  9  9\n 6  6  6  5  7\n\njulia> Ω_offsets = strel(CartesianIndex, Ω_mask) # custom neighborhood as displacement offset\n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(-1, -1)\n CartesianIndex(0, -1)\n CartesianIndex(1, -1)\n CartesianIndex(-1, 0)\n\njulia> out == extreme_filter(max, M, Ω_offsets) # both versions work equivalently\ntrue\n\nSee also the in-place version extreme_filter!. Another function in ImageFiltering package ImageFiltering.mapwindow provides similar functionality.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.extreme_filter!","page":"Reference","title":"ImageMorphology.extreme_filter!","text":"extreme_filter!(f, out, A; [r], [dims])\nextreme_filter!(f, out, A, Ω)\n\nThe in-place version of extreme_filter where out is the output array that gets modified.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.dilate","page":"Reference","title":"ImageMorphology.dilate","text":"dilate(img; dims=coords_spatial(img), r=1)\ndilate(img, se)\n\nPerform a max-filter over the neighborhood of img, specified by structuring element se.\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter, and half-size r to control the diamond size.\n\nExamples\n\njulia> img = falses(5, 5); img[3, [2, 4]] .= true; img\n5×5 BitMatrix:\n 0  0  0  0  0\n 0  0  0  0  0\n 0  1  0  1  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> dilate(img)\n5×5 BitMatrix:\n 0  0  0  0  0\n 1  1  1  1  1\n 1  1  1  1  1\n 1  1  1  1  1\n 0  0  0  0  0\n\njulia> dilate(img; dims=1)\n5×5 BitMatrix:\n 0  0  0  0  0\n 0  1  0  1  0\n 0  1  0  1  0\n 0  1  0  1  0\n 0  0  0  0  0\n\njulia> dilate(img, strel_diamond(img)) # use diamond shape SE\n5×5 BitMatrix:\n 0  0  0  0  0\n 0  1  0  1  0\n 1  1  1  1  1\n 0  1  0  1  0\n 0  0  0  0  0\n\nSee also\n\ndilate! is the in-place version of this function\nerode is the dual operator of dilate in the sense that complement.(dilate(img)) == erode(complement.(img)).\n\nnote: symmetricity\nIf se is symmetric with repsect to origin, i.e., se[b] == se[-b] for any b, then dilation becomes the Minkowski sum: A⊕B={a+b|a∈A, b∈B}.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.dilate!","page":"Reference","title":"ImageMorphology.dilate!","text":"dilate!(out, img; [dims], [r])\ndilate!(out, img, se)\n\nThe in-place version of dilate with input image img and output image out.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.erode","page":"Reference","title":"ImageMorphology.erode","text":"out = erode(img; dims=coords_spatial(img), r=1)\nout = erode(img, se)\n\nPerform a min-filter over the neighborhood of img, specified by structuring element se.\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter, and half-size r to control the diamond size.\n\nExamples\n\njulia> img = trues(5, 5); img[3, [2, 4]] .= false; img\n5×5 BitMatrix:\n 1  1  1  1  1\n 1  1  1  1  1\n 1  0  1  0  1\n 1  1  1  1  1\n 1  1  1  1  1\n\njulia> erode(img)\n5×5 BitMatrix:\n 1  1  1  1  1\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 1  1  1  1  1\n\njulia> erode(img; dims=1)\n5×5 BitMatrix:\n 1  1  1  1  1\n 1  0  1  0  1\n 1  0  1  0  1\n 1  0  1  0  1\n 1  1  1  1  1\n\njulia> erode(img, strel_diamond(img)) # use diamond shape SE\n5×5 BitMatrix:\n 1  1  1  1  1\n 1  0  1  0  1\n 0  0  0  0  0\n 1  0  1  0  1\n 1  1  1  1  1\n\nSee also\n\nerode! is the in-place version of this function\ndilate is the dual operator of erode in the sense that complement.(dilate(img)) == erode(complement.(img)).\n\nnote: symmetricity\nIf se is symmetric with repsect to origin, i.e., se[b] == se[-b] for any b, then erosion becomes the Minkowski difference: A⊖B={a-b|a∈A, b∈B}.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.erode!","page":"Reference","title":"ImageMorphology.erode!","text":"erode!(out, img; [dims], [r])\nerode!(out, img, se)\n\nThe in-place version of erode with input image img and output image out.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.opening","page":"Reference","title":"ImageMorphology.opening","text":"opening(img; dims=coords_spatial(img), r=1)\nopening(img, se)\n\nPerform the morphological opening on img. The opening operation is defined as erosion followed by a dilation: dilate(erode(img, se), se).\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter, and half-size r to control the diamond size.\n\nExamples\n\njulia> img = trues(7,7); img[2, 2] = false; img[3:5, 3:5] .= false; img[4, 4] = true; img\n7×7 BitMatrix:\n 1  1  1  1  1  1  1\n 1  0  1  1  1  1  1\n 1  1  0  0  0  1  1\n 1  1  0  1  0  1  1\n 1  1  0  0  0  1  1\n 1  1  1  1  1  1  1\n 1  1  1  1  1  1  1\n\njulia> opening(img)\n7×7 BitMatrix:\n 0  0  1  1  1  1  1\n 0  0  1  1  1  1  1\n 1  1  0  0  0  1  1\n 1  1  0  0  0  1  1\n 1  1  0  0  0  1  1\n 1  1  1  1  1  1  1\n 1  1  1  1  1  1  1\n\njulia> opening(img, strel_diamond(img)) # use diamond shape SE\n7×7 BitMatrix:\n 1  1  1  1  1  1  1\n 1  0  1  1  1  1  1\n 1  1  0  0  0  1  1\n 1  1  0  0  0  1  1\n 1  1  0  0  0  1  1\n 1  1  1  1  1  1  1\n 1  1  1  1  1  1  1\n\nSee also\n\nopening! is the in-place version of this function.\nclosing is the dual operator of opening in the sense that complement.(opening(img)) == closing(complement.(img)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.opening!","page":"Reference","title":"ImageMorphology.opening!","text":"opening!(out, img, buffer; [dims], [r])\nopening!(out, img, se, buffer)\n\nThe in-place version of opening with input image img and output image out. The intermediate erosion result is stored in buffer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.closing","page":"Reference","title":"ImageMorphology.closing","text":"closing(img; dims=coords_spatial(img), r=1)\nclosing(img, se)\n\nPerform the morphological closing on img. The closing operation is defined as dilation followed by an erosion: erode(dilate(img, se), se).\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter, and half-size r to control the diamond size.\n\nExamples\n\njulia> img = falses(7,7); img[2, 2] = true; img[3:5, 3:5] .= true; img[4, 4] = false; img\n7×7 BitMatrix:\n 0  0  0  0  0  0  0\n 0  1  0  0  0  0  0\n 0  0  1  1  1  0  0\n 0  0  1  0  1  0  0\n 0  0  1  1  1  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\njulia> closing(img)\n7×7 BitMatrix:\n 1  1  0  0  0  0  0\n 1  1  0  0  0  0  0\n 0  0  1  1  1  0  0\n 0  0  1  1  1  0  0\n 0  0  1  1  1  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\njulia> closing(img, strel_diamond(img)) # # use diamond shape SE\n7×7 BitMatrix:\n 0  0  0  0  0  0  0\n 0  1  0  0  0  0  0\n 0  0  1  1  1  0  0\n 0  0  1  1  1  0  0\n 0  0  1  1  1  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\nSee also\n\nopening! is the in-place version of this function.\nclosing is the dual operator of opening in the sense that complement.(opening(img)) == closing(complement.(img)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.closing!","page":"Reference","title":"ImageMorphology.closing!","text":"closing!(out, img, buffer; [dims], [r])\nclosing!(out, img, se, buffer)\n\nThe in-place version of closing with input image img and output image out. The intermediate dilation result is stored in buffer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.tophat","page":"Reference","title":"ImageMorphology.tophat","text":"tophat(img; dims=coords_spatial(img), r=1)\ntophat(img, se)\n\nPerforms morphological top-hat transform for given image, i.e., img - opening(img, se).\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter, and half-size r to control the diamond size.\n\nThis white top-hat transform can be used to extract small white elements and details from an image. To extract black details, the black top-hat transform, also known as bottom-hat transform, bothat can be used.\n\nExamples\n\njulia> img = falses(5, 5); img[1, 1] = true; img[3:5, 3:5] .= true; img\n5×5 BitMatrix:\n 1  0  0  0  0\n 0  0  0  0  0\n 0  0  1  1  1\n 0  0  1  1  1\n 0  0  1  1  1\n\njulia> Int.(tophat(img))\n5×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\njulia> Int.(tophat(img, strel_diamond(img))) # use diamond shape SE\n5×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  0  0  0  0\n 0  0  1  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.tophat!","page":"Reference","title":"ImageMorphology.tophat!","text":"tophat!(out, img, buffer; [dims], [r])\ntophat!(out, img, se, buffer)\n\nThe in-place version of tophat with input image img and output image out. The intermediate erosion result is stored in buffer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.bothat","page":"Reference","title":"ImageMorphology.bothat","text":"bothat(img; dims=coords_spatial(img), r=1)\nbothat(img, se)\n\nPerforms morphological bottom-hat transform for given image, i.e., closing(img, se) - img.\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter, and half-size r to control the diamond size.\n\nThis bottom-hat transform, also known as black top-hat transform, can be used to extract small black elements and details from an image. To extract white details, the white top-hat transform tophat can be used.\n\nExamples\n\njulia> img = falses(7, 7); img[3:5, 3:5] .= true; img[4, 6] = true; img[4, 4] = false; img\n7×7 BitMatrix:\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  1  1  1  0  0\n 0  0  1  0  1  1  0\n 0  0  1  1  1  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\njulia> Int.(bothat(img))\n7×7 Matrix{Int64}:\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  0  1  0  0  1\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\njulia> Int.(bothat(img, strel_diamond(img))) # use diamond shape SE\n7×7 Matrix{Int64}:\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  0  1  0  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\nSee also bothat! for the in-place version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.bothat!","page":"Reference","title":"ImageMorphology.bothat!","text":"bothat!(out, img, buffer; [dims], [r])\nbothat!(out, img, se, buffer)\n\nThe in-place version of bothat with input image img and output image out. The intermediate dilation result is stored in buffer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.mgradient","page":"Reference","title":"ImageMorphology.mgradient","text":"mgradient(img; mode=:beucher, dims=coords_spatial(img), r=1)\nmgradient(img, se; mode=:beucher)\n\nCalculate morphological gradient of the image using given mode.\n\nThere are three widely used modes[1]:\n\n:beucher: the default mode. It calculates the arithmetic difference between the dilation and the erosion – dilate(img, se) - erode(img, se).\n:internal: also known as half-gradient by erosion. It calculates the arithmetic difference between the original image and its erosion – img - erode(img, se).\n:external: also known as half-gradient by dilation. It calculates the arithmetic difference between dilation and the original image – dilate(img, se) - se.\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter, and half-size r to control the diamond size.\n\nExamples\n\njulia> img = falses(7, 7); img[3:5, 3:5] .= true; img\n7×7 BitMatrix:\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  1  1  1  0  0\n 0  0  1  1  1  0  0\n 0  0  1  1  1  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\njulia> Int.(mgradient(img)) # default mode :beucher always creates a two-pixel wide boundary\n7×7 Matrix{Int64}:\n 0  0  0  0  0  0  0\n 0  1  1  1  1  1  0\n 0  1  1  1  1  1  0\n 0  1  1  0  1  1  0\n 0  1  1  1  1  1  0\n 0  1  1  1  1  1  0\n 0  0  0  0  0  0  0\n\njulia> Int.(mgradient(img; mode=:internal)) # half-gradient -- the boundary is internal to original image\n7×7 Matrix{Int64}:\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  1  1  1  0  0\n 0  0  1  0  1  0  0\n 0  0  1  1  1  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\njulia> Int.(mgradient(img; mode=:external)) # half-gradient -- the boundary is external to original image\n7×7 Matrix{Int64}:\n 0  0  0  0  0  0  0\n 0  1  1  1  1  1  0\n 0  1  0  0  0  1  0\n 0  1  0  0  0  1  0\n 0  1  0  0  0  1  0\n 0  1  1  1  1  1  0\n 0  0  0  0  0  0  0\n\njulia> Int.(mgradient(img, strel_diamond(img))) # use diamond shape SE\n7×7 Matrix{Int64}:\n 0  0  0  0  0  0  0\n 0  0  1  1  1  0  0\n 0  1  1  1  1  1  0\n 0  1  1  0  1  1  0\n 0  1  1  1  1  1  0\n 0  0  1  1  1  0  0\n 0  0  0  0  0  0  0\n\nThe beucher operator is a self-complementary operator in the sense that mgradient(img, se; mode=:beucher) == mgradient(complement.(img), se; mode=:beucher). When r>1, it is usually called thick gradient. If a line segment is used as se, then the gradient becomes the directional gradient.\n\nSee also\n\nmgradient! is the in-place version of this function.\nmlaplacian for the laplacian operator.\nImageBase.FiniteDiff also provides a few finite difference operators, including fdiff, fgradient, etc.\n\nReferences\n\n[1] Rivest, Jean-Francois, Pierre Soille, and Serge Beucher. \"Morphological gradients.\" Journal of Electronic Imaging 2.4 (1993): 326-336.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.mgradient!","page":"Reference","title":"ImageMorphology.mgradient!","text":"mgradient!(out, img, buffer; [dims], [r], [mode])\nmgradient!(out, img, se, buffer; [mode])\n\nThe in-place version of mgradient with input image img and output image out.\n\nThe buffer array is required for :beucher mode. For :internal and :external modes, buffer is not needed and can be nothing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.mlaplacian","page":"Reference","title":"ImageMorphology.mlaplacian","text":"mlaplacian(img; dims=coords_spatial(img), r=1)\nmlaplacian(img, se)\n\nCalculate morphological laplacian of the image.\n\nThe morphological lapalacian operator is defined as ∇⁺A - ∇⁻A where ∇⁺A is the external gradient A - erode(A, se) and ∇⁻A is the internal gradient dilate(A, se) - A. Thus is dilate(A, se) + erode(A, se) - 2A.\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter.\n\nExamples\n\njulia> img = falses(7, 7); img[3:5, 3:5] .= true; img[4, 4] = false; img\n7×7 BitMatrix:\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n 0  0  1  1  1  0  0\n 0  0  1  0  1  0  0\n 0  0  1  1  1  0  0\n 0  0  0  0  0  0  0\n 0  0  0  0  0  0  0\n\njulia> Int.(mlaplacian(img))\n7×7 Matrix{Int64}:\n 0  0   0   0   0  0  0\n 0  1   1   1   1  1  0\n 0  1  -1  -1  -1  1  0\n 0  1  -1   1  -1  1  0\n 0  1  -1  -1  -1  1  0\n 0  1   1   1   1  1  0\n 0  0   0   0   0  0  0\n\njulia> Int.(mlaplacian(img, strel_diamond(img))) # use diamond shape SE\n7×7 Matrix{Int64}:\n 0  0   0   0   0  0  0\n 0  0   1   1   1  0  0\n 0  1  -1  -1  -1  1  0\n 0  1  -1   1  -1  1  0\n 0  1  -1  -1  -1  1  0\n 0  0   1   1   1  0  0\n 0  0   0   0   0  0  0\n\nSee also\n\nmlaplacian! is the in-place version of this function.\nmgradient for the gradient operator.\nImageBase.FiniteDiff also provides a few finite difference operators, including fdiff, fgradient, etc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.mlaplacian!","page":"Reference","title":"ImageMorphology.mlaplacian!","text":"mlaplacian!(out, img, buffer; [dims], [r])\nmlaplacian!(out, img, se, buffer)\n\nThe in-place version of mlaplacian with input image img and output image out. The intermediate erosion result is stored in buffer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Geodesic-operations","page":"Reference","title":"Geodesic operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"mreconstruct\nmreconstruct!\nunderbuild\nunderbuild!\noverbuild\noverbuild!","category":"page"},{"location":"reference/#ImageMorphology.mreconstruct","page":"Reference","title":"ImageMorphology.mreconstruct","text":"mreconstruct(op, marker, mask; [dims])\nmreconstruct(op, marker, mask, se)\n\nMorphological reconstruction of marker image by operation op.\n\nThe op argument is either erode or dilate, indicating reconstruction by erosion or by dilation. The mask argument has the same shape as marker and is used to restrict the output value range.\n\nThe dims keyword is used to specify the dimension to process by constructing the box shape structuring element strel_box(marker; dims). For generic structuring element, the half-size is expected to be either 0 or 1 along each dimension.\n\nBy definition, the reconstruction is done by applying marker = select.(op(marker; dims), mask) repeatly until reaching stability. For dilation op, select = dilate, min and for erosion op, select = erode, max.\n\nExamples\n\njulia> marker = [0 0 0 0 0; 0 9 0 0 0; 0 0 0 0 0; 0 0 0 5 0; 0 0 0 0 0; 0 9 0 0 0]\n6×5 Matrix{Int64}:\n 0  0  0  0  0\n 0  9  0  0  0\n 0  0  0  0  0\n 0  0  0  5  0\n 0  0  0  0  0\n 0  9  0  0  0\n\njulia> mask = [9 0 0 0 0; 0 8 7 1 0; 0 9 0 4 0; 0 0 0 4 0; 0 0 6 5 6; 0 0 9 8 9]\n6×5 Matrix{Int64}:\n 9  0  0  0  0\n 0  8  7  1  0\n 0  9  0  4  0\n 0  0  0  4  0\n 0  0  6  5  6\n 0  0  9  8  9\n\njulia> mreconstruct(dilate, marker, mask) # equivalent to underbuild(marker, mask)\n6×5 Matrix{Int64}:\n 8  0  0  0  0\n 0  8  7  1  0\n 0  8  0  4  0\n 0  0  0  4  0\n 0  0  4  4  4\n 0  0  4  4  4\n\nSee also\n\nThe inplace version of this function is mreconstruct!. There are also aliases underbuild for reconstruction by dilation and overbuild for reconstruction by erosion.\n\nReferences\n\n[1] L. Vincent, “Morphological grayscale reconstruction in image analysis: applications and efficient algorithms,” IEEE Trans. on Image Process., vol. 2, no. 2, pp. 176–201, Apr. 1993, doi: 10.1109/83.217222.\n[2] P. Soille, Morphological Image Analysis. Berlin, Heidelberg: Springer Berlin Heidelberg, 2004. doi: 10.1007/978-3-662-05088-0.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.mreconstruct!","page":"Reference","title":"ImageMorphology.mreconstruct!","text":"mreconstruct!(op, out, marker, mask; [dims])\n\nThe in-place version of morphological reconstruction mreconstruct.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.underbuild","page":"Reference","title":"ImageMorphology.underbuild","text":"underbuild(marker, mask; [dims])\nunderbuild(marker, mask, se)\n\nReconstruction by dilation. This is an alias for mreconstruct with op=dilate.\n\nSee also the in-place version underbuild!, and the dual operator overbuild.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.underbuild!","page":"Reference","title":"ImageMorphology.underbuild!","text":"underbuild!(out, marker, mask; [dims])\nunderbuild!(out, marker, mask, se)\n\nThe in-place version of underbuild with output image out being modified in place.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.overbuild","page":"Reference","title":"ImageMorphology.overbuild","text":"overbuild(marker, mask; [dims])\noverbuild(marker, mask, se)\n\nReconstruction by erosion. This is an alias for mreconstruct with op=erode.\n\nSee also the in-place version overbuild!, and the dual operator underbuild.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.overbuild!","page":"Reference","title":"ImageMorphology.overbuild!","text":"overbuild!(out, marker, mask; [dims])\noverbuild!(out, marker, mask, se)\n\nThe in-place version of overbuild with output image out being modified in place.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Components-and-segmentation","page":"Reference","title":"Components and segmentation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"label_components\nlabel_components!\ncomponent_boxes\ncomponent_lengths\ncomponent_indices\ncomponent_centroids","category":"page"},{"location":"reference/#ImageMorphology.label_components","page":"Reference","title":"ImageMorphology.label_components","text":"label = label_components(A; [dims=coords_spatial(A)], [r=1], [bkg])\nlabel = label_components(A, se; [bkg])\n\nFind and label the connected components of array A where the connectivity is defined by structuring element se. Each component is assigned a unique integer value as its label with 0 representing the background defined by bkg.\n\nse is the structuring element that defines the neighborhood of the image. See strel for more details. If se is not specified, then it will use the strel_box with an extra keyword dims to control the dimensions to filter, and half-size r to control the diamond size.\n\nExamples\n\njulia> A = [false true false true  false;\n            true false false  true  true]\n2×5 Matrix{Bool}:\n 0  1  0  1  0\n 1  0  0  1  1\n\njulia> label_components(A) # default diamond shape C4 connectivity\n2×5 Matrix{Int64}:\n 0  2  0  3  0\n 1  0  0  3  3\n\njulia> label_components(A; dims=2) # only the rows are considered\n2×5 Matrix{Int64}:\n 0  2  0  3  0\n 1  0  0  4  4\n\njulia> label_components(A, strel_box((3, 3))) # box shape C8 connectivity\n2×5 Matrix{Int64}:\n 0  1  0  2  0\n 1  0  0  2  2\n\nThe in-place version is label_components!. See also component_boxes, component_lengths, component_indices, component_centroids for basic properties of the labeled components.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.label_components!","page":"Reference","title":"ImageMorphology.label_components!","text":"label_components!(out, A; [dims], [r] [bkg])\nlabel_components!(out, A, se; [bkg])\n\nThe in-place version of label_components.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.component_boxes","page":"Reference","title":"ImageMorphology.component_boxes","text":"boxes = component_boxes(labeled_array)\n\nCalculates the minimal bounding boxes for each label including the background label. The labels can be computed by label_components.\n\nEach bounding box is represented as a CartesianIndices. boxes is shifted to 0-based indexing vector so that background region is boxes[0].\n\njulia> A = [2 2 2 2 2; 1 1 1 0 1; 1 0 2 1 1; 1 1 2 2 2; 1 0 2 2 2]\n5×5 Matrix{Int64}:\n 2  2  2  2  2\n 1  1  1  0  1\n 1  0  2  1  1\n 1  1  2  2  2\n 1  0  2  2  2\n\njulia> label = label_components(A) # four disjoint components\n5×5 Matrix{Int64}:\n 1  1  1  1  1\n 2  2  2  0  4\n 2  0  3  4  4\n 2  2  3  3  3\n 2  0  3  3  3\n\njulia> boxes = component_boxes(label) # get bounding boxes of all regions\n5-element OffsetArray(::Vector{CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}}, 0:4) with eltype CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}} with indices 0:4:\n CartesianIndices((2:5, 2:4))\n CartesianIndices((1:1, 1:5))\n CartesianIndices((2:5, 1:3))\n CartesianIndices((3:5, 3:5))\n CartesianIndices((2:3, 4:5))\n\njulia> A[boxes[1]] # crop the image region with label 1\n1×5 Matrix{Int64}:\n 2  2  2  2  2\n\njulia> A[boxes[4]] # crop the image region with label 4\n2×2 Matrix{Int64}:\n 0  1\n 1  1\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.component_lengths","page":"Reference","title":"ImageMorphology.component_lengths","text":"counts = component_lengths(labeled_array)\n\nCount the number of each labels in the input labeled array. counts is shifted to 0-based indexing vector so that the number of background pixels is counts[0].\n\njulia> A = [2 2 2 2 2; 1 1 1 0 1; 1 0 2 1 1; 1 1 2 2 2; 1 0 2 2 2]\n5×5 Matrix{Int64}:\n 2  2  2  2  2\n 1  1  1  0  1\n 1  0  2  1  1\n 1  1  2  2  2\n 1  0  2  2  2\n\njulia> label = label_components(A) # four disjoint components\n5×5 Matrix{Int64}:\n 1  1  1  1  1\n 2  2  2  0  4\n 2  0  3  4  4\n 2  2  3  3  3\n 2  0  3  3  3\n\njulia> component_lengths(label)\n5-element OffsetArray(::Vector{Int64}, 0:4) with eltype Int64 with indices 0:4:\n 3\n 5\n 7\n 7\n 3\n\nFor gray images, labels can be computed by label_components.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.component_indices","page":"Reference","title":"ImageMorphology.component_indices","text":"indices = component_indices([T], labeled_array)\n\nGet the indices of each label in the input labeled array. indices is shifted to 0-based indexing vector so that the indices of background pixels is indices[0].\n\nThe optional type T can be either Int/IndexLinear() or CartesianIndex/IndexCartesian() that is used to specify the type of the indices. The default choice is IndexStyle(labeled_array).\n\njulia> A = [2 2 2 2 2; 1 1 1 0 1; 1 0 2 1 1; 1 1 2 2 2; 1 0 2 2 2]\n5×5 Matrix{Int64}:\n 2  2  2  2  2\n 1  1  1  0  1\n 1  0  2  1  1\n 1  1  2  2  2\n 1  0  2  2  2\n\njulia> label = label_components(A) # four disjoint components\n5×5 Matrix{Int64}:\n 1  1  1  1  1\n 2  2  2  0  4\n 2  0  3  4  4\n 2  2  3  3  3\n 2  0  3  3  3\n\njulia> indices = component_indices(label)\n5-element OffsetArray(::Vector{Vector{Int64}}, 0:4) with eltype Vector{Int64} with indices 0:4:\n [8, 10, 17]\n [1, 6, 11, 16, 21]\n [2, 3, 4, 5, 7, 9, 12]\n [13, 14, 15, 19, 20, 24, 25]\n [18, 22, 23]\n\njulia> indices = component_indices(CartesianIndex, label)\n5-element OffsetArray(::Vector{Vector{CartesianIndex{2}}}, 0:4) with eltype Vector{CartesianIndex{2}} with indices 0:4:\n [CartesianIndex(3, 2), CartesianIndex(5, 2), CartesianIndex(2, 4)]\n [CartesianIndex(1, 1), CartesianIndex(1, 2), CartesianIndex(1, 3), CartesianIndex(1, 4), CartesianIndex(1, 5)]\n [CartesianIndex(2, 1), CartesianIndex(3, 1), CartesianIndex(4, 1), CartesianIndex(5, 1), CartesianIndex(2, 2), CartesianIndex(4, 2), CartesianIndex(2, 3)]\n [CartesianIndex(3, 3), CartesianIndex(4, 3), CartesianIndex(5, 3), CartesianIndex(4, 4), CartesianIndex(5, 4), CartesianIndex(4, 5), CartesianIndex(5, 5)]\n [CartesianIndex(3, 4), CartesianIndex(2, 5), CartesianIndex(3, 5)]\n\nFor gray images, labels can be computed by label_components.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.component_centroids","page":"Reference","title":"ImageMorphology.component_centroids","text":"centroids = component_centroids(labeled_array)\n\nCompute the centroid of each label in the input labeled array. centroids is shifted to 0-based indexing vector so that the centroid of background pixels is centroids[0].\n\nThe centroid of a finite set X, also known as geometric center, is calculated using sum(X)/length(X). For label i, all (Cartesian) indices of pixels with label i are used to build the set X\n\njulia> A = [2 2 2 2 2; 1 1 1 0 1; 1 0 2 1 1; 1 1 2 2 2; 1 0 2 2 2]\n5×5 Matrix{Int64}:\n 2  2  2  2  2\n 1  1  1  0  1\n 1  0  2  1  1\n 1  1  2  2  2\n 1  0  2  2  2\n\njulia> label = label_components(A) # four disjoint components\n5×5 Matrix{Int64}:\n 1  1  1  1  1\n 2  2  2  0  4\n 2  0  3  4  4\n 2  2  3  3  3\n 2  0  3  3  3\n\njulia> component_centroids(label)\n5-element OffsetArray(::Vector{Tuple{Float64, Float64}}, 0:4) with eltype Tuple{Float64, Float64} with indices 0:4:\n (3.3333333333333335, 2.6666666666666665)\n (1.0, 3.0)\n (3.142857142857143, 1.5714285714285714)\n (4.285714285714286, 3.857142857142857)\n (2.6666666666666665, 4.666666666666667)\n\nFor gray images, labels can be computed by label_components.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Max-tree","page":"Reference","title":"Max tree","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MaxTree\nareas\nboundingboxes\ndiameters\narea_opening\narea_opening!\narea_closing\narea_closing!\ndiameter_opening\ndiameter_opening!\ndiameter_closing\ndiameter_closing!\nlocal_maxima!\nlocal_maxima\nlocal_minima!\nlocal_minima\nImageMorphology.rebuild!\nImageMorphology.filter_components!","category":"page"},{"location":"reference/#ImageMorphology.MaxTree","page":"Reference","title":"ImageMorphology.MaxTree","text":"Max-tree morphological representation of an image.\n\nDetails\n\nLet's consider a thresholding operation,\n\n    mask = [val ≥ threshold for val in image]\n\nOne can identify the connected components (the sets of neighboring true values) in mask. When image thresholding is sequentially applied for all possible thresholds, it generates a collection of connected components that could be organized into a hierarchical structure called component tree. Consider 1D \"image\" with values 1, 2 and 3:\n\n       2233233312223322\n\nThe connected components would be\n\n    1: AAAAAAAAAAAAAAAA\n    2: BBBBBBBB.CCCCCCC\n    3: ..DD.EEE....FF..\n\nHere, the letters are the labels of the resulting connected components, and . specifies that the pixel value is below the threshold. In this example, the corresponding component tree is:\n\n      A\n     ⭩ ⭨\n    B   C\n   ⭩ ⭨   ⭨\n  D   E   F\n\nA max-tree is an efficient representation of the component tree. A connected component C at threshold level t is represented by the single reference pixel r from this level (image[r] == t), which is the parent to all other pixels of C and also to the reference pixels of the connected components at higher thresholds, which are the children of C. In our example, the reference pixels (denoted by the letter of the corresponding component) would be:\n\n    1: ........A.......\n    2: B........C......\n    3: ..D..E......F...\n\nI.e.\n\nComp Ref.Pixel\nA 9\nB 1\nC 10\nD 3\nE 6\nF 13\n\nSo the whole max-tree could be encoded as a vector of indices of parent pixels:\n\n9  1  1  3  1  1  6  6  9  9 10 10 10 13 10 10\n\nThe max-tree is the basis for many morphological operators, namely connected operators. Unlike morphological openings and closings, these operators do not require a fixed structuring element, but rather act with a flexible structuring element that meets a certain criterion.\n\nSee also\n\narea_opening, area_closing, diameter_opening, diameter_closing.\n\nReferences\n\nSalembier, P., Oliveras, A., & Garrido, L. (1998). Antiextensive Connected Operators for Image and Sequence Processing. IEEE Transactions on Image Processing, 7(4), 555-570.\nhttps://doi.org/10.1109/83.663500\nBerger, C., Geraud, T., Levillain, R., Widynski, N., Baillard, A., Bertin, E. (2007). Effective Component Tree Computation with Application to Pattern Recognition in Astronomical Imaging. In International Conference on Image Processing (ICIP), 41-44.\nhttps://doi.org/10.1109/ICIP.2007.4379949\nNajman, L., & Couprie, M. (2006). Building the component tree in quasi-linear time. IEEE Transactions on Image Processing, 15(11), 3531-3539.\nhttps://doi.org/10.1109/TIP.2006.877518\nCarlinet, E., & Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895.\nhttps://doi.org/10.1109/TIP.2014.2336551\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageMorphology.areas","page":"Reference","title":"ImageMorphology.areas","text":"areas(maxtree::MaxTree) -> Array{Int}\n\nComputes the areas of all maxtree components.\n\nReturns\n\nThe array of the same shape as the original image. The i-th element is the area (in pixels) of the component that is represented by the reference pixel with index i.\n\nSee also\n\ndiameters, area_opening, area_closing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.boundingboxes","page":"Reference","title":"ImageMorphology.boundingboxes","text":"boundingboxes(maxtree::MaxTree) -> Array{NTuple{2, CartesianIndex}}\n\nComputes the minimal bounding boxes of all maxtree components.\n\nReturns\n\nThe array of the same shape as the original image. The i-th element is the tuple of the minimal and maximal cartesian indices for the bounding box of the component that is represented by the reference pixel with index i.\n\nSee also\n\ndiameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.diameters","page":"Reference","title":"ImageMorphology.diameters","text":"diameters(maxtree::MaxTree) -> Array{Int}\n\nComputes the \"diameters\" of all maxtree components.\n\n\"Diameter\" of the max-tree connected component is the length of the widest side of the component's bounding box.\n\nReturns\n\nThe array of the same shape as the original image. The i-th element is the \"diameter\" of the component that is represented by the reference pixel with index i.\n\nSee also\n\nboundingboxes, areas, diameter_opening, diameter_closing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.area_opening","page":"Reference","title":"ImageMorphology.area_opening","text":"area_opening(image, [maxtree]; min_area=64, connectivity=1) -> Array\n\nPerforms an area opening of the image.\n\nArea opening replaces all bright components of an image that have a surface smaller than min_area with the darker value taken from their first ancestral component (in max-tree representation of image) that has the area no smaller than min_area.\n\nDetails\n\nArea opening is similar to morphological opening (see opening), but instead of using a fixed structuring element (e.g. disk) it employs small (less than min_area) components of the max-tree. Consequently, the area_opening with min_area = 1 is the identity transformation.\n\nIn the binary case, area opening is equivalent to remove_small_objects; this operator is thus extended to gray-level images.\n\nArguments\n\nimage::GenericGrayImage: the N-dimensional input image\nmin_area::Number=64: the smallest size (in pixels) of the image component to keep intact\nconnectivity::Integer=1: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.\nmaxtree::MaxTree: optional pre-built max-tree. Note that maxtree and connectivity optional parameters are mutually exclusive.\n\nReturns\n\nAn array of the same type and shape as the image.\n\nSee also\n\narea_opening!, area_closing, diameter_opening, MaxTree, opening\n\nReferences\n\nVincent, L. (1993). Grayscale area openings and closings, their efficient implementation and applications, Proc. of EURASIP Workshop on Mathematical Morphology and its Applications to Signal Processing, Barcelona, Spain, 22-27\nSoille, P. (2003). Chapter 6 Geodesic Metrics of Morphological Image Analysis: Principles and Applications, 2nd edition, Springer.\nhttps://doi.org/10.1007/978-3-662-05088-0\nSalembier, P., Oliveras, A., & Garrido, L. (1998). Antiextensive Connected Operators for Image and Sequence Processing. IEEE Transactions on Image Processing, 7(4), 555-570.\nhttps://doi.org/10.1109/83.663500\nNajman, L., & Couprie, M. (2006). Building the component tree in quasi-linear time. IEEE Transactions on Image Processing, 15(11), 3531-3539.\nhttps://doi.org/10.1109/TIP.2006.877518\nCarlinet, E., & Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895.\nhttps://doi.org/10.1109/TIP.2014.2336551\n\nExamples\n\nCreating a test image f (quadratic function with a maximum in the center and 4 additional local maxima):\n\njulia> w = 12;\n\njulia> f = [20 - 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];\n\njulia> f[3:4, 2:6] .= 40; f[3:5, 10:12] .= 60; f[10:12, 3:5] .= 80;\n\njulia> f[10:11, 10:12] .= 100; f[11, 11] = 100;\n\njulia> f_aopen = area_opening(f, min_area=8, connectivity=1);\n\nThe peaks with a surface smaller than 8 are removed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.area_opening!","page":"Reference","title":"ImageMorphology.area_opening!","text":"area_opening!(output, image, [maxtree];\n              min_area=64, connectivity=1) -> output\n\nPerforms in-place area opening of the image and stores the result in output. See area_opening for the detailed description of the method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.area_closing","page":"Reference","title":"ImageMorphology.area_closing","text":"area_closing(image, [maxtree]; min_area=64, connectivity=1) -> Array\n\nPerforms an area closing of the image.\n\nArea closing replaces all dark components of an image that have a surface smaller than min_area with the brighter value taken from their first ancestral component (in max-tree representation of image) that has the area no smaller than min_area.\n\nDetails\n\nArea closing is the dual operation to area opening (see area_opening). It is similar to morphological closings (see closing), but instead of using a fixed structuring element (e.g. disk) it employs small (less than min_area) components of the max-tree. Consequently, the area_closing with min_area = 1 is the identity transformation.\n\nIn the binary case, area closing is equivalent to remove_small_holes; this operator is thus extended to gray-level images.\n\nArguments\n\nimage::GenericGrayImage: the N-dimensional input image\nmin_area::Number=64: the smallest size (in pixels) of the image component to keep intact\nconnectivity::Integer=1: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.\nmaxtree::MaxTree: optional pre-built max-tree. Note that maxtree and connectivity optional parameters are mutually exclusive.\n\nReturns\n\nAn array of the same type and shape as the image.\n\nSee also\n\narea_closing!, area_opening, diameter_closing, MaxTree, closing\n\nReferences\n\nVincent, L. (1993). Grayscale area openings and closings, their efficient implementation and applications, Proc. of EURASIP Workshop on Mathematical Morphology and its Applications to Signal Processing, Barcelona, Spain, 22-27\nSoille, P. (2003). Chapter 6 Geodesic Metrics of Morphological Image Analysis: Principles and Applications, 2nd edition, Springer.\nhttps://doi.org/10.1007/978-3-662-05088-0\nSalembier, P., Oliveras, A., & Garrido, L. (1998). Antiextensive Connected Operators for Image and Sequence Processing. IEEE Transactions on Image Processing, 7(4), 555-570.\nhttps://doi.org/10.1109/83.663500\nNajman, L., & Couprie, M. (2006). Building the component tree in quasi-linear time. IEEE Transactions on Image Processing, 15(11), 3531-3539.\nhttps://doi.org/10.1109/TIP.2006.877518\nCarlinet, E., & Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895.\nhttps://doi.org/10.1109/TIP.2014.2336551\n\nExamples\n\nCreating a test image f (quadratic function with a minimum in the center and 4 additional local minima):\n\njulia> w = 12;\n\njulia> f = [180 + 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];\n\njulia> f[3:4, 2:6] .= 40; f[3:5, 10:12] .= 60; f[10:12, 3:5] .= 80;\n\njulia> f[10:11, 10:12] .= 100; f[11, 11] = 100;\n\njulia> f_aclose = area_closing(f, min_area=8, connectivity=1);\n\nAll small minima are removed, and the remaining minima have at least a size of 8.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.area_closing!","page":"Reference","title":"ImageMorphology.area_closing!","text":"area_closing!(output, image, [maxtree];\n              min_area=64, connectivity=1) -> output\n\nPerforms in-place area closing of the image and stores the result in output. See area_closing for the detailed description of the method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.diameter_opening","page":"Reference","title":"ImageMorphology.diameter_opening","text":"diameter_opening(image, [maxtree]; min_diameter=8, connectivity=1) -> Array\n\nPerforms a diameter opening of the image.\n\nDiameter opening replaces all bright structures of an image that have the diameter (the widest dimension of their bounding box) smaller than min_diameter with the darker value taken from their first ancestral component (in max-tree representation of image) that has the diameter no smaller than min_diameter.\n\nThe operator is also called Bounding Box Opening. In practice, the result is similar to a morphological opening, but long and thin structures are not removed.\n\nArguments\n\nimage::GenericGrayImage: the N-dimensional input image\nmin_diameter::Number=8: the minimal length (in pixels) of the widest dimension of the bounding box of the image component to keep intact\nconnectivity::Integer=1: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.\nmaxtree::MaxTree: optional pre-built max-tree. Note that maxtree and connectivity optional parameters are mutually exclusive.\n\nReturns\n\nAn array of the same type and shape as the image.\n\nSee also\n\ndiameter_opening!, diameter_closing, area_opening, MaxTree, opening\n\nReferences\n\nWalter, T., & Klein, J.-C. (2002). Automatic Detection of Microaneurysms in Color Fundus Images of the Human Retina by Means of the Bounding Box Closing. In A. Colosimo, P. Sirabella, A. Giuliani (Eds.), Medical Data Analysis. Lecture Notes in Computer Science, vol 2526, 210-220. Springer Berlin Heidelberg.\nhttps://doi.org/10.1007/3-540-36104-9_23\nCarlinet, E., & Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895.\nhttps://doi.org/10.1109/TIP.2014.2336551\n\nExamples\n\nCreating a test image f (quadratic function with a maximum in the center and 4 additional local maxima):\n\njulia> w = 12;\n\njulia> f = [20 - 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];\n\njulia> f[3:4, 2:6] .= 40; f[3:5, 10:12] .= 60; f[10:12, 3:5] .= 80;\n\njulia> f[10:11, 10:12] .= 100; f[11, 11] = 100;\n\njulia> f_dopen = diameter_opening(f, min_diameter=3, connectivity=1);\n\nThe peaks with a maximal diameter of 2 or less are removed. For the remaining peaks the widest side of the bounding box is at least 3.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.diameter_opening!","page":"Reference","title":"ImageMorphology.diameter_opening!","text":"diameter_opening!(output, image, [maxtree];\n                  min_diameter=8, connectivity=1) -> output\n\nPerforms in-place diameter opening of the image and stores the result in output. See diameter_opening for the detailed description of the method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.diameter_closing","page":"Reference","title":"ImageMorphology.diameter_closing","text":"diameter_closing(image, [maxtree]; min_diameter=8, connectivity=1) -> Array\n\nPerforms a diameter closing of the image.\n\nDiameter closing replaces all dark structures of an image that have the diameter (the widest dimension of their bounding box) smaller than min_diameter with the brighter value taken from their first ancestral component (in max-tree representation of image) that has the diameter no smaller than min_diameter.\n\nArguments\n\nimage::GenericGrayImage: the N-dimensional input image\nmin_diameter::Number=8: the minimal length (in pixels) of the widest dimension of the bounding box of the image component to keep intact\nconnectivity::Integer=1: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.\nmaxtree::MaxTree: optional pre-built max-tree. Note that maxtree and connectivity optional parameters are mutually exclusive.\n\nReturns\n\nAn array of the same type and shape as the image.\n\nSee also\n\ndiameter_closing!, diameter_opening, area_closing, MaxTree, closing\n\nReferences\n\nWalter, T., & Klein, J.-C. (2002). Automatic Detection of Microaneurysms in Color Fundus Images of the Human Retina by Means of the Bounding Box Closing. In A. Colosimo, P. Sirabella, A. Giuliani (Eds.), Medical Data Analysis. Lecture Notes in Computer Science, vol 2526, 210-220. Springer Berlin Heidelberg.\nhttps://doi.org/10.1007/3-540-36104-9_23\nCarlinet, E., & Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895.\nhttps://doi.org/10.1109/TIP.2014.2336551\n\nExamples\n\nCreating a test image f (quadratic function with a minimum in the center and 4 additional local minima):\n\njulia> w = 12;\n\njulia> f = [180 + 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];\n\njulia> f[3:4, 2:6] .= 40; f[3:5, 10:12] .= 60; f[10:12, 3:5] .= 80;\n\njulia> f[10:11, 10:12] .= 100; f[11, 11] = 100;\n\njulia> f_dclose = diameter_closing(f, min_diameter=3, connectivity=1);\n\nAll small minima with a diameter of 2 or less are removed. For the remaining minima the widest bounding box side is at least 3.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.diameter_closing!","page":"Reference","title":"ImageMorphology.diameter_closing!","text":"diameter_closing!(output, image, [maxtree];\n                  min_diameter=8, connectivity=1) -> output\n\nPerforms in-place diameter closing of the image and stores the result in output. See diameter_closing for the detailed description of the method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.local_maxima!","page":"Reference","title":"ImageMorphology.local_maxima!","text":"local_maxima!(output, image, [maxtree]; connectivity=1) -> output\n\nDetects the local maxima of image and stores the result in output. See local_maxima for the detailed description of the method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.local_maxima","page":"Reference","title":"ImageMorphology.local_maxima","text":"local_maxima(image, [maxtree]; connectivity=1) -> Array\n\nDetermines and labels all local maxima of the image.\n\nDetails\n\nThe local maximum is defined as the connected set of pixels that have the same value, which is greater than the values of all pixels in direct neighborhood of the set.\n\nTechnically, the implementation is based on the max-tree representation of an image. It's beneficial if the max-tree is already computed, otherwise ImageFiltering.findlocalmaxima would be more efficient.\n\nArguments\n\nimage::GenericGrayImage: the N-dimensional input image\nconnectivity::Integer=1: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.\nmaxtree::MaxTree: optional pre-built max-tree. Note that maxtree and connectivity optional parameters are mutually exclusive.\n\nReturns\n\nAn integer array of the same shape as the image. Pixels that are not local maxima have 0 value. Pixels of the same local maximum share the same positive value (the local maximum id).\n\nSee also\n\nMaxTree, local_maxima!, local_minima, ImageFiltering.findlocalmaxima\n\nExamples\n\nCreate f (quadratic function with a maximum in the center and 4 additional constant maxima):\n\njulia> w = 10;\n\njulia> f = [20 - 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];\n\njulia> f[3:5, 3:5] .= 40; f[3:5, 8:10] .= 60; f[8:10, 3:5] .= 80; f[8:10, 8:10] .= 100;\n\njulia> f_maxima = local_maxima(f); # Get all local maxima of `f`\n\nThe resulting image contains the 4 labeled local maxima.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.local_minima!","page":"Reference","title":"ImageMorphology.local_minima!","text":"local_minima!(output, image, [maxtree]; connectivity=1) -> output\n\nDetects the local minima of image and stores the result in output. See local_minima for the detailed description of the method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.local_minima","page":"Reference","title":"ImageMorphology.local_minima","text":"local_minima(image, [maxtree]; connectivity=1) -> Array\n\nDetermines and labels all local minima of the image.\n\nDetails\n\nThe local minimum is defined as the connected set of pixels that have the same value, which is less than the values of all pixels in direct neighborhood of the set.\n\nTechnically, the implementation is based on the max-tree representation of an image. It's beneficial if the max-tree is already computed, otherwise ImageFiltering.findlocalminima would be more efficient.\n\nArguments\n\nimage::GenericGrayImage: the N-dimensional input image\nconnectivity::Integer=1: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.\nmaxtree::MaxTree: optional pre-built max-tree. Note that maxtree and connectivity optional parameters are mutually exclusive.\n\nReturns\n\nAn integer array of the same shape as the image. Pixels that are not local minima have 0 value. Pixels of the same local minimum share the same positive value (the local minimum id).\n\nSee also\n\nMaxTree, local_minima!, local_maxima, ImageFiltering.findlocalminima\n\nExamples\n\nCreate f (quadratic function with a minimum in the center and 4 additional constant minimum):\n\njulia> w = 10;\n\njulia> f = [180 + 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];\n\njulia> f[3:5, 3:5] .= 40; f[3:5, 8:10] .= 60; f[8:10, 3:5] .= 80; f[8:10, 8:10] .= 100;\n\njulia> f_minima = local_minima(f); # Calculate all local minima of `f`\n\nThe resulting image contains the labeled local minima.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.rebuild!","page":"Reference","title":"ImageMorphology.rebuild!","text":"rebuild!(maxtree::MaxTree, image::GenericGrayImage,\n         neighbors::AbstractVector{CartesianIndex}) -> maxtree\n\nRebuilds the maxtree for the image using neighbors as the pixel connectivity specification.\n\nDetails\n\nThe pixels in the connected components generated by the method should be connected to each other by a path through neighboring pixels. The pixels p_1 and p_2 are neighbors, if neighbors array contains d, such that p_2 = p_1 + d.\n\nSee also\n\nMaxTree\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.filter_components!","page":"Reference","title":"ImageMorphology.filter_components!","text":"filter_components!(output::GenericGrayImage, image::GenericGrayImage,\n                   maxtree::MaxTree, attrs::AbstractVector,\n                   min_attr, all_below_min) -> output\n\nFilters the connected components of the image and stores the result in output.\n\nThe output is the copy of the image exluding the connected components, whose attribute value is below min_attr. That is, the pixels of the exluded component are reset to the value of the reference pixel of its first valid ancestor (the connected component with the attribute value greater or equal to min_attr).\n\nArguments\n\nmaxtree::MaxTree: pre-built max-tree representation of the image\nattrs::AbstractVector: attrs[i] is the attribute value for the i-th  component of the tree (i being the linear index of its reference pixel)\nall_below_min: the value to fill the output if all attributes of all components (including the root one) are below min_attr\n\nDetails\n\nThis function is the basis for area_opening, diameter_opening and similar transformations. E.g. for area_opening the attribute is the area of the components. In this case, the max-tree components of the output have area no smaller than min_attr pixels.\n\nThe method assumes that the attribute values are monotone with respect to the components hieararchy, i.e. attrsi = attrsmaxtreeparentindicesi for each i.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Feature-transform","page":"Reference","title":"Feature transform","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"feature_transform\ndistance_transform\nclearborder","category":"page"},{"location":"reference/#ImageMorphology.FeatureTransform.feature_transform","page":"Reference","title":"ImageMorphology.FeatureTransform.feature_transform","text":"feature_transform(img::AbstractArray{Bool, N};\n                  weights=nothing, nthreads=Threads.nthreads()) -> F\n\nCompute the feature transform of a binary image I, finding the closest \"feature\" (positions where I is true) for each location in I.  Specifically, F[i] is a CartesianIndex encoding the position closest to i for which I[F[i]] is true.  In cases where two or more features in I have the same distance from i, an arbitrary feature is chosen. If I has no true values, then all locations are mapped to an index where each coordinate is typemin(Int).\n\nOptionally specify the weight w assigned to each coordinate.  For example, if I corresponds to an image where voxels are anisotropic, w could be the voxel spacing along each coordinate axis. The default value of nothing is equivalent to w=(1,1,...).\n\nSee also: distance_transform.\n\nCitation\n\n[1] Maurer, Calvin R., Rensheng Qi, and Vijay Raghavan. \"A linear time algorithm for computing exact Euclidean distance transforms of binary images in arbitrary dimensions.\" IEEE Transactions on Pattern Analysis and Machine Intelligence 25.2 (2003): 265-270.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.FeatureTransform.distance_transform","page":"Reference","title":"ImageMorphology.FeatureTransform.distance_transform","text":"distance_transform(F::AbstractArray{CartesianIndex}, [w=nothing]) -> D\n\nCompute the distance transform of F, where each element F[i] represents a \"target\" or \"feature\" location assigned to i. Specifically, D[i] is the distance between i and F[i]. Optionally specify the weight w assigned to each coordinate; the default value of nothing is equivalent to w=(1,1,...).\n\nSee also: feature_transform.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.clearborder","page":"Reference","title":"ImageMorphology.clearborder","text":"cleared_img = clearborder(img)\ncleared_img = clearborder(img, width)\ncleared_img = clearborder(img, width, background)\n\nReturns a copy of the original image after clearing objects connected to the border of the image. Parameters:\n\nimg          = Binary/Grayscale input image\nwidth        = Width of the border examined (Default value is 1)\nbackground   = Value to be given to pixels/elements that are cleared (Default value is 0)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Misc","page":"Reference","title":"Misc","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"convexhull\nisboundary\nisboundary!\nImageMorphology.isboundary_thick","category":"page"},{"location":"reference/#ImageMorphology.convexhull","page":"Reference","title":"ImageMorphology.convexhull","text":"chull = convexhull(img)\n\nComputes the convex hull of a binary image and returns the vertices of convex hull as a CartesianIndex array.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.isboundary","page":"Reference","title":"ImageMorphology.isboundary","text":"isboundary(img::AbstractArray; background = 0, dims = coords_spatial(A), kwargs...)\n\nFinds the boundaries that are just within each object. background is the scalar value of the background pixels which will not be marked as boundaries. Keyword arguments are passed to extremefilt! which include dims indicating the dimension(s) over which to discover boundaries.\n\nSee also its in-place version isboundary! and the alternative version that finds thick boundaries, isboundary_thick.\n\nExamples\n\nDocTestSetup = quote\n    import ImageMorphology: isboundary\nend\n\njulia> A = zeros(Int64, 16, 16); A[4:8, 4:8] .= 5; A[4:8, 9:12] .= 6; A[10:12,13:15] .= 3; A[10:12,3:6] .= 9; A\n16×16 Matrix{Int64}:\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0\n 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0\n 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0\n 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0\n 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0\n 0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0\n 0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\njulia> isboundary(A)\n16×16 Matrix{Int64}:\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0\n 0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0\n 0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0\n 0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0\n 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0\n 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0\n 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\njulia> isboundary(A .!= 0)\n16×16 BitMatrix:\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0\n 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0\n 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0\n 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\njulia> isboundary(A .!= 0; dims = 1)\n16×16 BitMatrix:\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\njulia> isboundary(A .!= 0; dims = 2)\n16×16 BitMatrix:\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0\n 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0\n 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0\n 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.isboundary!","page":"Reference","title":"ImageMorphology.isboundary!","text":"isboundary!(img::AbstractArray; background = 0, dims = coords_spatial(A), kwargs...)\n\nFinds the boundaries that are just within each object, replacing the original image. background is the scalar value of the background pixels which will not be marked as boundaries. Keyword arguments are passed to extreme_filter which include dims indicating the dimension(s) over which to discover boundaries.\n\nSee out-of-place version, isboundary, for examples.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageMorphology.isboundary_thick","page":"Reference","title":"ImageMorphology.isboundary_thick","text":"isboundary_thick(img::AbstractArray; dims = coords_spatial(img), kwargs...)\n\nFind thick boundaries that are just outside and just inside the objects. This is a union of the inner and outer boundaries. Keyword dims indicates over which dimensions to look for boundaries. This dims and additional keywords kwargs are passed to extreme_filter.\n\nSee also isboundary which just yields the inner boundaries.\n\nExamples\n\nDocTestSetup = quote\n    import ImageMorphology: isboundary_thick\nend\n\n```jldoctest julia> A = zeros(Int64, 16, 16); A[4:8, 4:8] .= 5; A[4:8, 9:12] .= 6; A[10:12,13:15] .= 3; A[10:12,3:6] .= 9; A 16×16 Matrix{Int64}:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0  0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0  0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\njulia> isboundary_thick(A) 16×16 BitMatrix:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  0  0  0  0  0  1  1  0  0  0  1  1  0  0  1  1  0  0  0  0  0  1  1  0  0  0  1  1  0  0  1  1  0  0  0  0  0  1  1  0  0  0  1  1  0  0  1  1  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  0  1  1  0  0  1  1  0  0  0  0  1  1  0  1  1  0  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  0  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\njulia> isboundary_thick(A) .& (A .!= 0) 16×16 BitMatrix:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n\njulia> isboundary_thick(A) == isboundary(A; background = -1) true\n\njulia> isboundary_thick(A) .& (A .!= 0) == isboundary(A) # inner boundaries true\n\njulia> isboundary_thick(A .!= 0) .& (A .== 0)  == isboundary(A .== 0) # outer boundaries true  ```\n\n\n\n\n\n","category":"function"},{"location":"operators/#op_index","page":"Morphology Operators","title":"Morphology Operators","text":"","category":"section"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"This page describes the interfaces for the basic morphology operators that you can use to build your own pipeline. To easily visualize the effect of different operators, the \"blobs\" image is used to build the cover image.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"using TestImages, ImageBase\nrestrict(testimage(\"blobs\"))","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"note: color image is not supported\nUnless explicitly used, most operations in this package don't support color images. This is because many morphological operation is based on pixel value comparisons min, max, > and < – they are not well-defined for RGB type.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"note: 🚧 work in progress\nThis page contains only a subset of exported functions. The missing ones will be added in the future. You might need to check the heavy reference page to find out what you need. Contributions are welcome!","category":"page"},{"location":"operators/#Operators","page":"Morphology Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card-section\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"extreme_filter","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"The extreme_filter function is the core operation in ImageMorphology. Many other morphological operations such as dilate and erode are direct usages of it. The cover image shows a pixel jitter using random select function.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"dilate","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"The dilation operator dilate is essentially a max filter. This is a basic term in mathematical morphology – many operations are built on top of dilate and the erode operator.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"erode","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"The dilation operator erode is essentially a min filter. This is a basic term in mathematical morphology – many operations are built on top of erode and the dilate operator.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"opening","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"opening operator is defined as dilate(erode(img)). Intuitively, opening operation fills the white holes in the image.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"closing","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"closing operator is defined as dilate(erode(img)). Intuitively, closing operation fills the black holes in the image.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"tophat","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"The (white) tophat operator is defined as img - opening(img). Intuitively, this filter can be used to extract small white elements and details from an image.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"bothat","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"The (black) tophat operator, also known as bottom hat, is defined as closing(img) - img. Intuitively, this filter can be used to extract small black elements and details from an image.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"mgradient","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"There are three commonly used morphological gradient definitions: the beucher gradident dilate(img) - erode(img), the external half-gradient dilate(img) - img, and the internal half-gradident img - erode(img).","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"mlaplacian","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"Laplacian operator is defined as the difference between external gradient and internal gradient – mgradient(img; mode=:external) - mgradient(img; mode=:internal).","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"mreconstruct","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"The morphological reconstruction operator is to repeatedly apply particular operator until the stability, i.e,. output unchanged. The most widely used ones are reconstruction by dilation and reconstruction by erosion.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"underbuild","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"underbuild is reconstruction by dilation, it is an alias for mreconstruct when op=dilate.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"<div class=\"list-card\">\n<table>\n  <td valign=\"bottom\"><div class=\"list-card-cover\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"(Image: list-card-cover-image)","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"  </div></td>\n  <td><div class=\"list-card-text\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"overbuild","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>\n    <div class=\"list-card-description\">","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"overbuild is reconstruction by erosion, it is an alias for mreconstruct when op=erode.","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"    </div>\n  </td>\n</tbody></table>\n</div>","category":"page"},{"location":"operators/","page":"Morphology Operators","title":"Morphology Operators","text":"</div>","category":"page"},{"location":"operators/operators/dilate/#op_dilate","page":"dilate","title":"dilate","text":"","category":"section"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"The dilation operator dilate is essentially a max filter. This is a basic term in mathematical morphology – many operations are built on top of dilate and the erode operator.","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\n\nimg = restrict(testimage_dip3e(\"fig1005\")) # wirebond mask","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"For each pixel, dilation is the maximum of the pixels in the neighborhood. In mathematics, dilate(A, Ω) is defined as delta_Ap = supAp+o  o in Omega where Ω is the structuring element.","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"The simplest usage is dilate(img; [dims], [r]), where dims and r controls the neighborhood shape.","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"out1 = dilate(img) # default: all spatial dimensions, r=1, a box-shape SE\nout2 = dilate(img; dims=(2,)) # only apply to the second dimension\nout3 = dilate(img; r=5) # half-size r=5\nmosaic(out1, out2, out3; nrow=1)","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"It uses the strel_box to create a box-shaped structuring element. You can also provide a custom SE via the dilate(img, se) interface.","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"out1 = dilate(img, strel_box((3, 3))) # default se for`dilate(img)`\nse = centered(Bool[1 1 1; 1 1 0; 0 0 0]) # match top-left region\nout2 = dilate(img, se)\nmosaic(out1, out2; nrow=1)","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"An in-place version dilate! is also provided, for instance","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"out1 = similar(img)\ndilate!(out1, img)\n\nout2 = similar(img)\ndilate!(out2, img, strel_diamond((3, 3)))\nnothing #hide","category":"page"},{"location":"operators/operators/dilate/#See-also","page":"dilate","title":"See also","text":"","category":"section"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"erode is the dual operator of dilate in the following sense:","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"complement.(dilate(img)) == erode(complement.(img))","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"For bool arrays and symmetric SEs, dilation becomes equivalent to the minkowski addition on sets: A oplus B =  a+b  a in A b in B .","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"For a comprehensive and more accurate documentation, please check the dilate reference page.","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"","category":"page"},{"location":"operators/operators/dilate/","page":"dilate","title":"dilate","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"operators/operators/mlaplacian/#op_mlaplacian","page":"mlaplacian","title":"mlaplacian","text":"","category":"section"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"(Image: Source code)","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"Laplacian operator is defined as the difference between external gradient and internal gradient – mgradient(img; mode=:external) - mgradient(img; mode=:internal).","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"using ImageMorphology\nusing TestImages\nusing ImageBase\nusing ImageShow\n\nimg = restrict(testimage_dip3e(\"fig0940\")) # rice\nimg01 = @. Gray(img > 0.5)\nmosaic(img, img01; nrow=1)","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"mosaic(mlaplacian(img), mlaplacian(img01); nrow=1)","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"Note that laplacian can produce negative values:","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"A = falses(7, 7)\nA[3:5, 3:5] .= true\nA[4, 4] = false\nInt.(mlaplacian(A))","category":"page"},{"location":"operators/operators/mlaplacian/#See-also","page":"mlaplacian","title":"See also","text":"","category":"section"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"ImageBase.jl provides the finite-difference version of laplace operator flaplacian. ImageFiltering.jl provides Laplacian and LaplacianOfGaussian kernels.","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"fout = abs.(ImageBase.FiniteDiff.flaplacian(img))\nmout = abs.(mlaplacian(img))\nmosaic(fout, mout; nrow=1)","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"For a comprehensive and more accurate documentation, please check the mlaplacian reference page.","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"","category":"page"},{"location":"operators/operators/mlaplacian/","page":"mlaplacian","title":"mlaplacian","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"#ImageMorphology.jl","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"","category":"section"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"This package provides morphology operations for structure analysis and image processing.","category":"page"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"info: setup\nImageMorphology is a sub-package of the umbrella package Images.jl – either using Images or using ImageMorphology will give you access to this functionality.","category":"page"},{"location":"#Installation","page":"ImageMorphology.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"Just like all normal Julia packages, you can use Pkg to install it:","category":"page"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"pkg> add ImageMorphology # hit ] to enter Pkg mode","category":"page"},{"location":"#Learn","page":"ImageMorphology.jl","title":"Learn","text":"","category":"section"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"The perhaps quickest way to use this library is to find a set of useful operators from the gallery and build your own pipeline from it.","category":"page"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"For any advanced usage, we recommend you to read the \"Concept\" part. For instance, many morphology operation supports generic \"structuring element\".","category":"page"},{"location":"#Overview","page":"ImageMorphology.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"The following tables give an overview of ImageMorphology functionalities.","category":"page"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"note: 🚧 work in progress\nThis overview is not yet finished and only contains a subset of exported functions. The missing functions will be added in the future. You might still need to check the heavy reference page to find out what you need. Contributions are welcome!","category":"page"},{"location":"#Structuring-Element-(SE)","page":"ImageMorphology.jl","title":"Structuring Element (SE)","text":"","category":"section"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"Structuring element is the key concept in morphology. If you're not familiar with this, please read concept: structuring element first.","category":"page"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"name summary\nstrel convert between different SE representations\nstrel_type infer the SE type\nstrel_size get the minimal block size that contains the SE\nstrel_chain and strel_product compose multiple SEs into a bigger one\nstrel_box construct a box-shaped SE, e.g., C8, C26 connectivity\nstrel_diamond construct a diamond-shaped SE, e.g., C4, C6 connectivity\ncentered shift the array center to (0, 0, ..., 0)","category":"page"},{"location":"#Basic-morphological-operations","page":"ImageMorphology.jl","title":"Basic morphological operations","text":"","category":"section"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"name summary examples\nextreme_filter and extreme_filter! iteratively apply a select function f(x, y) to each neighborhood extreme_filter operation\ndilate and dilate! morphological max filter dilate operation\nerode and erode! morphological min filter erode operation\nopening and opening! fills white holes opening operation\nclosing and closing! fills black holes closing operation\nbothat and bothat! extract black details bothat operation\ntophat and tophat! extract white details tophat operation\nmgradient and mgradient! morphological gradient mgradient operation\nmlaplacian and mlaplacian! morpholigical laplacian mlaplacian operation","category":"page"},{"location":"#Geodesic-operations","page":"ImageMorphology.jl","title":"Geodesic operations","text":"","category":"section"},{"location":"","page":"ImageMorphology.jl","title":"ImageMorphology.jl","text":"name summary examples\nunderbuild morphological reconstruction by dilation, see also mreconstruct underbuild operation and mreconstruct operation\nunderbuild morphological reconstruction by erosion, see also mreconstruct overbuild operation and mreconstruct operation","category":"page"}]
}
