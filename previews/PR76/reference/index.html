<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ImageMorphology</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../democards/listtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImageMorphology</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ImageMorphology.jl</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../structuring_element/">Structuring element</a></li></ul></li><li><a class="tocitem" href="../operators/">Morphology Operators</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#reference_se"><span>Structuring element</span></a></li><li><a class="tocitem" href="#reference_ops"><span>Morphological operations</span></a></li><li><a class="tocitem" href="#Components-and-segmentation"><span>Components and segmentation</span></a></li><li><a class="tocitem" href="#Max-tree"><span>Max tree</span></a></li><li><a class="tocitem" href="#Feature-transform"><span>Feature transform</span></a></li><li><a class="tocitem" href="#Misc"><span>Misc</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="reference_index"><a class="docs-heading-anchor" href="#reference_index">Reference</a><a id="reference_index-1"></a><a class="docs-heading-anchor-permalink" href="#reference_index" title="Permalink"></a></h1><h2 id="reference_se"><a class="docs-heading-anchor" href="#reference_se">Structuring element</a><a id="reference_se-1"></a><a class="docs-heading-anchor-permalink" href="#reference_se" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.strel" href="#ImageMorphology.strel"><code>ImageMorphology.strel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strel([T], X::AbstractArray)</code></pre><p>Convert structuring element (SE) <code>X</code> to appropriate presentation format with element type <code>T</code>. This is a useful tool to generate SE that most ImageMorphology functions understand.</p><p>ImageMorphology currently supports two commonly used representations:</p><ul><li><code>T=CartesianIndex</code>: offsets to its center point. The output type is <code>Vector{CartesianIndex{N}}</code>.</li><li><code>T=Bool</code>: connectivity mask where <code>true</code> indicates connected to its center point. The output type is <code>BitArray{N}</code>.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; se_mask = centered(Bool[1 1 0; 1 1 0; 0 0 0]) # connectivity mask
3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:
 1  1  0
 1  1  0
 0  0  0

julia&gt; se_offsets = strel(CartesianIndex, se_mask) # displacement offsets to its center point
3-element Vector{CartesianIndex{2}}:
 CartesianIndex(-1, -1)
 CartesianIndex(0, -1)
 CartesianIndex(-1, 0)

julia&gt; se = strel(Bool, se_offsets)
3×3 OffsetArray(::BitMatrix, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:
 1  1  0
 1  1  0
 0  0  0</code></pre><p>See also <a href="#ImageMorphology.strel_diamond"><code>strel_diamond</code></a> and <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> for SE constructors for two special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L292-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.strel_box" href="#ImageMorphology.strel_box"><code>ImageMorphology.strel_box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strel_box(A; r=1)
strel_box(size; r=size .÷ 2)</code></pre><p>Construct the N-dimensional structuring element (SE) with all elements in the local window connected.</p><p>If image <code>A</code> is provided, then the SE size will be <code>(2r+1, 2r+1, ...)</code> with default half-size <code>r=1</code>. If <code>size</code> is provided, the default <code>r</code> will be <code>size .÷ 2</code>. The default <code>dims</code> will be all dimensions, that is, <code>(1, 2, ..., length(size))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; img = rand(64, 64);

julia&gt; strel_box(img)
3×3 ImageMorphology.SEBoxArray{2, UnitRange{Int64}} with indices -1:1×-1:1:
 1  1  1
 1  1  1
 1  1  1

julia&gt; strel_box(img; r=2)
5×5 ImageMorphology.SEBoxArray{2, UnitRange{Int64}} with indices -2:2×-2:2:
 1  1  1  1  1
 1  1  1  1  1
 1  1  1  1  1
 1  1  1  1  1
 1  1  1  1  1

julia&gt; strel_box((5,5); r=(1,2))
5×5 ImageMorphology.SEBoxArray{2, UnitRange{Int64}} with indices -2:2×-2:2:
 0  0  0  0  0
 1  1  1  1  1
 1  1  1  1  1
 1  1  1  1  1
 0  0  0  0  0</code></pre><div class="admonition is-info"><header class="admonition-header">specialization and performance</header><div class="admonition-body"><p>The box shape <code>SEBox</code> is a special type for which many morphology algorithms may provide efficient implementations. For this reason, if one tries to collect an <code>SEBoxArray</code> into other array types (e.g. <code>Array{Bool}</code> via <code>collect</code>), then a significant performance drop is very likely to occur.</p></div></div><p>See also <a href="#ImageMorphology.strel"><code>strel</code></a> and <a href="#ImageMorphology.strel_box"><code>strel_box</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L406-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.strel_diamond" href="#ImageMorphology.strel_diamond"><code>ImageMorphology.strel_diamond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strel_diamond(A::AbstractArray, [dims]; r=1)
strel_diamond(size, [dims]; [r])</code></pre><p>Construct the N-dimensional structuring element (SE) for a diamond shape.</p><p>If image <code>A</code> is provided, then the SE size will be <code>(2r+1, 2r+1, ...)</code> with default half-size <code>r=1</code>. If <code>size</code> is provided, the default <code>r</code> will be <code>maximum(size)÷2</code>. The default <code>dims</code> will be all dimensions, that is, <code>(1, 2, ..., length(size))</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; img = rand(64, 64);

julia&gt; strel_diamond(img) # default size for image input is (3, 3)
3×3 ImageMorphology.SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -1:1×-1:1:
 0  1  0
 1  1  1
 0  1  0

julia&gt; strel_diamond(img; r=2) # equivalent to `strel_diamond((5,5))`
5×5 ImageMorphology.SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -2:2×-2:2:
 0  0  1  0  0
 0  1  1  1  0
 1  1  1  1  1
 0  1  1  1  0
 0  0  1  0  0

julia&gt; strel_diamond(img, (1,)) # mask along dimension 1
3×1 ImageMorphology.SEDiamondArray{2, 1, UnitRange{Int64}, 1} with indices -1:1×0:0:
 1
 1
 1

julia&gt; strel_diamond((3,3), (1,)) # 3×3 mask along dimension 1
3×3 ImageMorphology.SEDiamondArray{2, 1, UnitRange{Int64}, 1} with indices -1:1×-1:1:
 0  1  0
 0  1  0
 0  1  0</code></pre><div class="admonition is-info"><header class="admonition-header">specialization and performance</header><div class="admonition-body"><p>The diamond shape <code>SEDiamond</code> is a special type for which many morphology algorithms may provide much more efficient implementations. For this reason, if one tries to collect an <code>SEDiamondArray</code> into other array types (e.g. <code>Array{Bool}</code> via <code>collect</code>), then a significant performance drop is very likely to occur.</p></div></div><p>See also <a href="#ImageMorphology.strel"><code>strel</code></a> and <a href="#ImageMorphology.strel_box"><code>strel_box</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L342-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.strel_type" href="#ImageMorphology.strel_type"><code>ImageMorphology.strel_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strel_type(x)</code></pre><p>Infer the structuring element type for <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.strel_size" href="#ImageMorphology.strel_size"><code>ImageMorphology.strel_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strel_size(x)</code></pre><p>Calculate the minimal block size that contains the structuring element. The result will be a tuple of odd integers.</p><pre><code class="language-julia-repl hljs">julia&gt; se = strel_diamond((5, 5); r=1)
5×5 ImageMorphology.SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -2:2×-2:2:
 0  0  0  0  0
 0  0  1  0  0
 0  1  1  1  0
 0  0  1  0  0
 0  0  0  0  0

julia&gt; strel_size(se) # is not (5, 5)
(3, 3)

julia&gt; strel(Bool, strel(CartesianIndex, se)) # because it only checks the minimal enclosing block
3×3 OffsetArray(::BitMatrix, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:
 0  1  0
 1  1  1
 0  1  0

julia&gt; se = [CartesianIndex(1, 1), CartesianIndex(-2, -2)];

julia&gt; strel_size(se) # is not (4, 4)
(5, 5)

julia&gt; strel(Bool, se) # because the connectivity mask has to be odd size
5×5 OffsetArray(::BitMatrix, -2:2, -2:2) with eltype Bool with indices -2:2×-2:2:
 1  0  0  0  0
 0  0  0  0  0
 0  0  1  0  0
 0  0  0  1  0
 0  0  0  0  0

julia&gt; se = strel_diamond((5, 5), (1, ); r=1)
5×5 ImageMorphology.SEDiamondArray{2, 1, UnitRange{Int64}, 1} with indices -2:2×-2:2:
 0  0  0  0  0
 0  0  1  0  0
 0  0  1  0  0
 0  0  1  0  0
 0  0  0  0  0

julia&gt; strel_size(se)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L229-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.strel_ndims" href="#ImageMorphology.strel_ndims"><code>ImageMorphology.strel_ndims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strel_ndims(x)::Int</code></pre><p>Infer the dimension of the structuring element <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OffsetArrays.centered" href="#OffsetArrays.centered"><code>OffsetArrays.centered</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centered(A, cp=center(A)) -&gt; Ao</code></pre><p>Shift the center coordinate/point <code>cp</code> of array <code>A</code> to <code>(0, 0, ..., 0)</code>. Internally, this is equivalent to <code>OffsetArray(A, .-cp)</code>.</p><div class="admonition is-compat"><header class="admonition-header">OffsetArrays 1.9</header><div class="admonition-body"><p>This method requires at least OffsetArrays 1.9.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:9), 3, 3)
3×3 Matrix{Int64}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; Ao = OffsetArrays.centered(A); # axes (-1:1, -1:1)

julia&gt; Ao[0, 0]
5

julia&gt; Ao = OffsetArray(A, OffsetArrays.Origin(0)); # axes (0:2, 0:2)

julia&gt; Aoo = OffsetArrays.centered(Ao); # axes (-1:1, -1:1)

julia&gt; Aoo[0, 0]
5</code></pre><p>Users are allowed to pass <code>cp</code> to change how &quot;center point&quot; is interpreted, but the meaning of the output array should be reinterpreted as well. For instance, if <code>cp = map(last, axes(A))</code> then this function no longer shifts the center point but instead the bottom-right point to <code>(0, 0, ..., 0)</code>. A commonly usage of <code>cp</code> is to change the rounding behavior when the array is of even size at some dimension:</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:4), 2, 2) # Ideally the center should be (1.5, 1.5) but OffsetArrays only support integer offsets
2×2 Matrix{Int64}:
 1  3
 2  4

julia&gt; OffsetArrays.centered(A, OffsetArrays.center(A, RoundUp)) # set (2, 2) as the center point
2×2 OffsetArray(::Matrix{Int64}, -1:0, -1:0) with eltype Int64 with indices -1:0×-1:0:
 1  3
 2  4

julia&gt; OffsetArrays.centered(A, OffsetArrays.center(A, RoundDown)) # set (1, 1) as the center point
2×2 OffsetArray(::Matrix{Int64}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:
 1  3
 2  4</code></pre><p>See also <a href="#OffsetArrays.center"><code>center</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OffsetArrays.center" href="#OffsetArrays.center"><code>OffsetArrays.center</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">center(A, [r::RoundingMode=RoundDown])::Dims</code></pre><p>Return the center coordinate of given array <code>A</code>. If <code>size(A, k)</code> is even, a rounding procedure will be applied with mode <code>r</code>.</p><div class="admonition is-compat"><header class="admonition-header">OffsetArrays 1.9</header><div class="admonition-body"><p>This method requires at least OffsetArrays 1.9.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:9), 3, 3)
3×3 Matrix{Int64}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; c = OffsetArrays.center(A)
(2, 2)

julia&gt; A[c...]
5

julia&gt; Ao = OffsetArray(A, -2, -2); # axes (-1:1, -1:1)

julia&gt; c = OffsetArrays.center(Ao)
(0, 0)

julia&gt; Ao[c...]
5</code></pre><p>To shift the center coordinate of the given array to <code>(0, 0, ...)</code>, you can use <a href="#OffsetArrays.centered"><code>centered</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.is_symmetric" href="#ImageMorphology.is_symmetric"><code>ImageMorphology.is_symmetric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_symmetric(se)</code></pre><p>Check if a given structuring element array <code>se</code> is symmetric with respect to its center pixel.</p><p>More formally, this checks if <code>mask[I] == mask[-I]</code> for any valid <code>I ∈ CartesianIndices(mask)</code> in the connectivity mask represetation <code>mask = strel(Bool, se)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/utils.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.SEMask" href="#ImageMorphology.SEMask"><code>ImageMorphology.SEMask</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SEMask{N}()</code></pre><p>A (holy) trait type for representing structuring element as connectivity mask. This connectivity mask SE is a bool array where <code>true</code> indicates that pixel position is connected to the center point.</p><pre><code class="language-julia-repl hljs">julia&gt; se = centered(Bool[0 1 0; 1 1 1; 0 1 0]) # commonly known as C4 connectivity
3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:
 0  1  0
 1  1  1
 0  1  0

julia&gt; strel_type(se)
ImageMorphology.SEMask{2}()</code></pre><p>See also <a href="#ImageMorphology.SEOffset"><code>SEOffset</code></a> for the displacement offset representation. More details can be found on he documentation page <a href="../structuring_element/#concept_se">Structuring Element</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L13-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.SEOffset" href="#ImageMorphology.SEOffset"><code>ImageMorphology.SEOffset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SEOffset{N}()</code></pre><p>A (holy) trait type for representing structuring element as displacement offsets. This displacement offsets SE is an array of <code>CartesianIndex</code> where each element stores the displacement offset from the center point.</p><pre><code class="language-julia-repl hljs">julia&gt; se = [CartesianIndex(-1, 0), CartesianIndex(0, -1), CartesianIndex(1, 0), CartesianIndex(0, 1)]
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(-1, 0)
 CartesianIndex(0, -1)
 CartesianIndex(1, 0)
 CartesianIndex(0, 1)

julia&gt; strel_type(se)
ImageMorphology.SEOffset{2}()</code></pre><p>See also <a href="#ImageMorphology.SEMask"><code>SEMask</code></a> for the connectivity mask representation. More details can be found on he documentation page <a href="../structuring_element/#concept_se">Structuring Element</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L37-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.SEDiamond" href="#ImageMorphology.SEDiamond"><code>ImageMorphology.SEDiamond</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SEDiamond{N}(axes, [dims]; [r])</code></pre><p>A (holy) trait type for the N-dimensional diamond shape structuring element. This is a special case of <a href="#ImageMorphology.SEMask"><code>SEMask</code></a> that ImageMorphology algorithms might provide optimized implementation.</p><p>It is recommended to use <a href="#ImageMorphology.strel_diamond"><code>strel_diamond</code></a> and <a href="#ImageMorphology.strel_type"><code>strel_type</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; using OffsetArrays: centered

julia&gt; se = strel_diamond((3, 3)) # C4 connectivity
3×3 ImageMorphology.SEDiamondArray{2, 2, UnitRange{Int64}, 0} with indices -1:1×-1:1:
 0  1  0
 1  1  1
 0  1  0

julia&gt; strel_type(se)
ImageMorphology.SEDiamond{2, 2, UnitRange{Int64}}((-1:1, -1:1), (1, 2), 1)

julia&gt; se = centered(collect(se)) # converted to normal centered array
3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:
 0  1  0
 1  1  1
 0  1  0

julia&gt; strel_type(se)
ImageMorphology.SEMask{2}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L61-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.SEBox" href="#ImageMorphology.SEBox"><code>ImageMorphology.SEBox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SEBox{N}(axes; [r])</code></pre><p>The N-dimensional structuring element with all elements connected. This is a special case of <a href="#ImageMorphology.SEMask"><code>SEMask</code></a> that ImageMorphology algorithms might provide optimized implementation.</p><p>It is recommended to use <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> and <a href="#ImageMorphology.strel_type"><code>strel_type</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; using OffsetArrays: centered

julia&gt; se = strel_box((3, 3)) # C8 connectivity
3×3 ImageMorphology.SEBoxArray{2, UnitRange{Int64}} with indices -1:1×-1:1:
 1  1  1
 1  1  1
 1  1  1

julia&gt; strel_type(se)
ImageMorphology.SEBox{2, UnitRange{Int64}}((-1:1, -1:1), (1, 1))

julia&gt; se = centered(collect(se)) # converted to normal centered array
3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:
 1  1  1
 1  1  1
 1  1  1

julia&gt; strel_type(se)
ImageMorphology.SEMask{2}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L112-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.SEDiamondArray" href="#ImageMorphology.SEDiamondArray"><code>ImageMorphology.SEDiamondArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SEDiamondArray(se::SEDiamond)</code></pre><p>The instantiated array object of <a href="#ImageMorphology.SEDiamond"><code>SEDiamond</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.SEBoxArray" href="#ImageMorphology.SEBoxArray"><code>ImageMorphology.SEBoxArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SEBoxArray(se::SEBox)</code></pre><p>The instantiated array object of <a href="#ImageMorphology.SEBox"><code>SEBox</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/structuring_element.jl#L187-L191">source</a></section></article><h2 id="reference_ops"><a class="docs-heading-anchor" href="#reference_ops">Morphological operations</a><a id="reference_ops-1"></a><a class="docs-heading-anchor-permalink" href="#reference_ops" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.extreme_filter" href="#ImageMorphology.extreme_filter"><code>ImageMorphology.extreme_filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extreme_filter(f, A; r=1, [dims]) -&gt; out
extreme_filter(f, A, Ω) -&gt; out</code></pre><p>Filter the array <code>A</code> using select function <code>f(x, y)</code> for each Ω-neighborhood. The name &quot;extreme&quot; comes from the fact that typical select function <code>f</code> choice is <code>min</code> and <code>max</code>.</p><p>For each pixel <code>p</code> in <code>A</code>, the select function <code>f</code> is applied to its Ω-neighborhood iteratively in a <code>f(...(f(f(A[p], A[p+Ω[1]]), A[p+Ω[2]]), ...)</code> manner. For instance, in the 1-dimensional case, <code>out[p] = f(f(A[p], A[p-1]), A[p+1])</code> for each <code>p</code> is the default behavior.</p><p>The Ω-neighborhood is defined by the <code>dims</code> or <code>Ω</code> argument. The <code>r</code> and <code>dims</code> keywords specifies the box shape neighborhood <code>Ω</code> using <a href="#ImageMorphology.strel_box"><code>strel_box</code></a>. The <code>Ω</code> is also known as structuring element (SE), it can be either displacement offsets or bool array mask, please refer to <a href="#ImageMorphology.strel"><code>strel</code></a> for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [4 6 5 3 4; 8 6 9 4 8; 7 8 4 9 6; 6 2 2 1 7; 1 6 5 2 6]
5×5 Matrix{Int64}:
 4  6  5  3  4
 8  6  9  4  8
 7  8  4  9  6
 6  2  2  1  7
 1  6  5  2  6

julia&gt; extreme_filter(max, M) # max-filter using 4 direct neighbors along both dimensions
5×5 Matrix{Int64}:
 8  9  9  9  8
 8  9  9  9  9
 8  9  9  9  9
 8  8  9  9  9
 6  6  6  7  7

julia&gt; extreme_filter(max, M; dims=1) # max-filter along the first dimension (column)
5×5 Matrix{Int64}:
 8  6  9  4  8
 8  8  9  9  8
 8  8  9  9  8
 7  8  5  9  7
 6  6  5  2  7</code></pre><p><code>Ω</code> can be either an <code>AbstractArray{Bool}</code> mask array with <code>true</code> element indicating connectivity, or a <code>AbstractArray{&lt;:CartesianIndex}</code> array with each element indicating the displacement offset to its center element.</p><pre><code class="language-julia-repl hljs">julia&gt; Ω_mask = centered(Bool[1 1 0; 1 1 0; 1 0 0]) # custom neighborhood in mask format
3×3 OffsetArray(::Matrix{Bool}, -1:1, -1:1) with eltype Bool with indices -1:1×-1:1:
 1  1  0
 1  1  0
 1  0  0

julia&gt; out = extreme_filter(max, M, Ω_mask)
5×5 Matrix{Int64}:
 4  8  6  9  4
 8  8  9  9  9
 8  8  9  9  9
 7  8  8  9  9
 6  6  6  5  7

julia&gt; Ω_offsets = strel(CartesianIndex, Ω_mask) # custom neighborhood as displacement offset
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(-1, -1)
 CartesianIndex(0, -1)
 CartesianIndex(1, -1)
 CartesianIndex(-1, 0)

julia&gt; out == extreme_filter(max, M, Ω_offsets) # both versions work equivalently
true</code></pre><p>See also the in-place version <a href="#ImageMorphology.extreme_filter!"><code>extreme_filter!</code></a>. Another function in ImageFiltering package <code>ImageFiltering.mapwindow</code> provides similar functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/extreme_filter.jl#L3-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.extreme_filter!" href="#ImageMorphology.extreme_filter!"><code>ImageMorphology.extreme_filter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extreme_filter!(f, out, A; [r], [dims])
extreme_filter!(f, out, A, Ω)</code></pre><p>The in-place version of <a href="#ImageMorphology.extreme_filter"><code>extreme_filter</code></a> where <code>out</code> is the output array that gets modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/extreme_filter.jl#L84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.dilate" href="#ImageMorphology.dilate"><code>ImageMorphology.dilate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dilate(img; dims=coords_spatial(img), r=1)
dilate(img, se)</code></pre><p>Perform a max-filter over the neighborhood of <code>img</code>, specified by structuring element <code>se</code>.</p><p><code>se</code> is the structuring element that defines the neighborhood of the image. See <a href="#ImageMorphology.strel"><code>strel</code></a> for more details. If <code>se</code> is not specified, then it will use the <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> with an extra keyword <code>dims</code> to control the dimensions to filter, and half-size <code>r</code> to control the diamond size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; img = falses(5, 5); img[3, [2, 4]] .= true; img
5×5 BitMatrix:
 0  0  0  0  0
 0  0  0  0  0
 0  1  0  1  0
 0  0  0  0  0
 0  0  0  0  0

julia&gt; dilate(img)
5×5 BitMatrix:
 0  0  0  0  0
 1  1  1  1  1
 1  1  1  1  1
 1  1  1  1  1
 0  0  0  0  0

julia&gt; dilate(img; dims=1)
5×5 BitMatrix:
 0  0  0  0  0
 0  1  0  1  0
 0  1  0  1  0
 0  1  0  1  0
 0  0  0  0  0

julia&gt; dilate(img, strel_diamond(img)) # use diamond shape SE
5×5 BitMatrix:
 0  0  0  0  0
 0  1  0  1  0
 1  1  1  1  1
 0  1  0  1  0
 0  0  0  0  0</code></pre><p><strong>See also</strong></p><ul><li><a href="#ImageMorphology.dilate!"><code>dilate!</code></a> is the in-place version of this function</li><li><a href="#ImageMorphology.erode"><code>erode</code></a> is the dual operator of <code>dilate</code> in the sense that <code>complement.(dilate(img)) == erode(complement.(img))</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">symmetricity</header><div class="admonition-body"><p>If <code>se</code> is symmetric with repsect to origin, i.e., <code>se[b] == se[-b]</code> for any <code>b</code>, then dilation becomes the Minkowski sum: A⊕B={a+b|a∈A, b∈B}.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/dilate.jl#L1-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.dilate!" href="#ImageMorphology.dilate!"><code>ImageMorphology.dilate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dilate!(out, img; [dims], [r])
dilate!(out, img, se)</code></pre><p>The in-place version of <a href="#ImageMorphology.dilate"><code>dilate</code></a> with input image <code>img</code> and output image <code>out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/dilate.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.erode" href="#ImageMorphology.erode"><code>ImageMorphology.erode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">out = erode(img; dims=coords_spatial(img), r=1)
out = erode(img, se)</code></pre><p>Perform a min-filter over the neighborhood of <code>img</code>, specified by structuring element <code>se</code>.</p><p><code>se</code> is the structuring element that defines the neighborhood of the image. See <a href="#ImageMorphology.strel"><code>strel</code></a> for more details. If <code>se</code> is not specified, then it will use the <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> with an extra keyword <code>dims</code> to control the dimensions to filter, and half-size <code>r</code> to control the diamond size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; img = trues(5, 5); img[3, [2, 4]] .= false; img
5×5 BitMatrix:
 1  1  1  1  1
 1  1  1  1  1
 1  0  1  0  1
 1  1  1  1  1
 1  1  1  1  1

julia&gt; erode(img)
5×5 BitMatrix:
 1  1  1  1  1
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 1  1  1  1  1

julia&gt; erode(img; dims=1)
5×5 BitMatrix:
 1  1  1  1  1
 1  0  1  0  1
 1  0  1  0  1
 1  0  1  0  1
 1  1  1  1  1

julia&gt; erode(img, strel_diamond(img)) # use diamond shape SE
5×5 BitMatrix:
 1  1  1  1  1
 1  0  1  0  1
 0  0  0  0  0
 1  0  1  0  1
 1  1  1  1  1</code></pre><p><strong>See also</strong></p><ul><li><a href="#ImageMorphology.erode!"><code>erode!</code></a> is the in-place version of this function</li><li><a href="#ImageMorphology.dilate"><code>dilate</code></a> is the dual operator of <code>erode</code> in the sense that <code>complement.(dilate(img)) == erode(complement.(img))</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">symmetricity</header><div class="admonition-body"><p>If <code>se</code> is symmetric with repsect to origin, i.e., <code>se[b] == se[-b]</code> for any <code>b</code>, then erosion becomes the Minkowski difference: A⊖B={a-b|a∈A, b∈B}.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/erode.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.erode!" href="#ImageMorphology.erode!"><code>ImageMorphology.erode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">erode!(out, img; [dims], [r])
erode!(out, img, se)</code></pre><p>The in-place version of <a href="#ImageMorphology.erode"><code>erode</code></a> with input image <code>img</code> and output image <code>out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/erode.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.opening" href="#ImageMorphology.opening"><code>ImageMorphology.opening</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opening(img; dims=coords_spatial(img), r=1)
opening(img, se)</code></pre><p>Perform the morphological opening on <code>img</code>. The opening operation is defined as erosion followed by a dilation: <code>dilate(erode(img, se), se)</code>.</p><p><code>se</code> is the structuring element that defines the neighborhood of the image. See <a href="#ImageMorphology.strel"><code>strel</code></a> for more details. If <code>se</code> is not specified, then it will use the <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> with an extra keyword <code>dims</code> to control the dimensions to filter, and half-size <code>r</code> to control the diamond size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; img = trues(7,7); img[2, 2] = false; img[3:5, 3:5] .= false; img[4, 4] = true; img
7×7 BitMatrix:
 1  1  1  1  1  1  1
 1  0  1  1  1  1  1
 1  1  0  0  0  1  1
 1  1  0  1  0  1  1
 1  1  0  0  0  1  1
 1  1  1  1  1  1  1
 1  1  1  1  1  1  1

julia&gt; opening(img)
7×7 BitMatrix:
 0  0  1  1  1  1  1
 0  0  1  1  1  1  1
 1  1  0  0  0  1  1
 1  1  0  0  0  1  1
 1  1  0  0  0  1  1
 1  1  1  1  1  1  1
 1  1  1  1  1  1  1

julia&gt; opening(img, strel_diamond(img)) # use diamond shape SE
7×7 BitMatrix:
 1  1  1  1  1  1  1
 1  0  1  1  1  1  1
 1  1  0  0  0  1  1
 1  1  0  0  0  1  1
 1  1  0  0  0  1  1
 1  1  1  1  1  1  1
 1  1  1  1  1  1  1</code></pre><p><strong>See also</strong></p><ul><li><a href="#ImageMorphology.opening!"><code>opening!</code></a> is the in-place version of this function.</li><li><a href="#ImageMorphology.closing"><code>closing</code></a> is the dual operator of <code>opening</code> in the sense that <code>complement.(opening(img)) == closing(complement.(img))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/opening.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.opening!" href="#ImageMorphology.opening!"><code>ImageMorphology.opening!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opening!(out, img, buffer; [dims], [r])
opening!(out, img, se, buffer)</code></pre><p>The in-place version of <a href="#ImageMorphology.opening"><code>opening</code></a> with input image <code>img</code> and output image <code>out</code>. The intermediate erosion result is stored in <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/opening.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.closing" href="#ImageMorphology.closing"><code>ImageMorphology.closing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closing(img; dims=coords_spatial(img), r=1)
closing(img, se)</code></pre><p>Perform the morphological closing on <code>img</code>. The closing operation is defined as dilation followed by an erosion: <code>erode(dilate(img, se), se)</code>.</p><p><code>se</code> is the structuring element that defines the neighborhood of the image. See <a href="#ImageMorphology.strel"><code>strel</code></a> for more details. If <code>se</code> is not specified, then it will use the <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> with an extra keyword <code>dims</code> to control the dimensions to filter, and half-size <code>r</code> to control the diamond size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; img = falses(7,7); img[2, 2] = true; img[3:5, 3:5] .= true; img[4, 4] = false; img
7×7 BitMatrix:
 0  0  0  0  0  0  0
 0  1  0  0  0  0  0
 0  0  1  1  1  0  0
 0  0  1  0  1  0  0
 0  0  1  1  1  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0

julia&gt; closing(img)
7×7 BitMatrix:
 1  1  0  0  0  0  0
 1  1  0  0  0  0  0
 0  0  1  1  1  0  0
 0  0  1  1  1  0  0
 0  0  1  1  1  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0

julia&gt; closing(img, strel_diamond(img)) # # use diamond shape SE
7×7 BitMatrix:
 0  0  0  0  0  0  0
 0  1  0  0  0  0  0
 0  0  1  1  1  0  0
 0  0  1  1  1  0  0
 0  0  1  1  1  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0</code></pre><p><strong>See also</strong></p><ul><li><a href="#ImageMorphology.opening!"><code>opening!</code></a> is the in-place version of this function.</li><li><a href="#ImageMorphology.closing"><code>closing</code></a> is the dual operator of <code>opening</code> in the sense that <code>complement.(opening(img)) == closing(complement.(img))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/closing.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.closing!" href="#ImageMorphology.closing!"><code>ImageMorphology.closing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closing!(out, img, buffer; [dims], [r])
closing!(out, img, se, buffer)</code></pre><p>The in-place version of <a href="#ImageMorphology.closing"><code>closing</code></a> with input image <code>img</code> and output image <code>out</code>. The intermediate dilation result is stored in <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/closing.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.tophat" href="#ImageMorphology.tophat"><code>ImageMorphology.tophat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tophat(img; dims=coords_spatial(img), r=1)
tophat(img, se)</code></pre><p>Performs morphological top-hat transform for given image, i.e., <code>img - opening(img, se)</code>.</p><p><code>se</code> is the structuring element that defines the neighborhood of the image. See <a href="#ImageMorphology.strel"><code>strel</code></a> for more details. If <code>se</code> is not specified, then it will use the <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> with an extra keyword <code>dims</code> to control the dimensions to filter, and half-size <code>r</code> to control the diamond size.</p><p>This <em>white</em> top-hat transform can be used to extract small white elements and details from an image. To extract black details, the <em>black</em> top-hat transform, also known as bottom-hat transform, <a href="#ImageMorphology.bothat"><code>bothat</code></a> can be used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; img = falses(5, 5); img[1, 1] = true; img[3:5, 3:5] .= true; img
5×5 BitMatrix:
 1  0  0  0  0
 0  0  0  0  0
 0  0  1  1  1
 0  0  1  1  1
 0  0  1  1  1

julia&gt; Int.(tophat(img))
5×5 Matrix{Int64}:
 1  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0

julia&gt; Int.(tophat(img, strel_diamond(img))) # use diamond shape SE
5×5 Matrix{Int64}:
 1  0  0  0  0
 0  0  0  0  0
 0  0  1  0  0
 0  0  0  0  0
 0  0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/tophat.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.tophat!" href="#ImageMorphology.tophat!"><code>ImageMorphology.tophat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tophat!(out, img, buffer; [dims], [r])
tophat!(out, img, se, buffer)</code></pre><p>The in-place version of <a href="#ImageMorphology.tophat"><code>tophat</code></a> with input image <code>img</code> and output image <code>out</code>. The intermediate erosion result is stored in <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/tophat.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.bothat" href="#ImageMorphology.bothat"><code>ImageMorphology.bothat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bothat(img; dims=coords_spatial(img), r=1)
bothat(img, se)</code></pre><p>Performs morphological bottom-hat transform for given image, i.e., <code>closing(img, se) - img</code>.</p><p><code>se</code> is the structuring element that defines the neighborhood of the image. See <a href="#ImageMorphology.strel"><code>strel</code></a> for more details. If <code>se</code> is not specified, then it will use the <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> with an extra keyword <code>dims</code> to control the dimensions to filter, and half-size <code>r</code> to control the diamond size.</p><p>This bottom-hat transform, also known as <em>black</em> top-hat transform, can be used to extract small black elements and details from an image. To extract white details, the <em>white</em> top-hat transform <a href="#ImageMorphology.tophat"><code>tophat</code></a> can be used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; img = falses(7, 7); img[3:5, 3:5] .= true; img[4, 6] = true; img[4, 4] = false; img
7×7 BitMatrix:
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  1  1  1  0  0
 0  0  1  0  1  1  0
 0  0  1  1  1  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0

julia&gt; Int.(bothat(img))
7×7 Matrix{Int64}:
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  0  1  0  0  1
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0

julia&gt; Int.(bothat(img, strel_diamond(img))) # use diamond shape SE
7×7 Matrix{Int64}:
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  0  1  0  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0</code></pre><p>See also <a href="#ImageMorphology.bothat!"><code>bothat!</code></a> for the in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/bothat.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.bothat!" href="#ImageMorphology.bothat!"><code>ImageMorphology.bothat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bothat!(out, img, buffer; [dims], [r])
bothat!(out, img, se, buffer)</code></pre><p>The in-place version of <a href="#ImageMorphology.bothat"><code>bothat</code></a> with input image <code>img</code> and output image <code>out</code>. The intermediate dilation result is stored in <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/bothat.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.morphogradient" href="#ImageMorphology.morphogradient"><code>ImageMorphology.morphogradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">morphogradient(img; dims=coords_spatial(img), r=1)
morphogradient(img, se)</code></pre><p>Calculate morphological (Beucher) gradient of the image, i.e., <code>dilate(img, se) - erode(img, se)</code>.</p><p><code>se</code> is the structuring element that defines the neighborhood of the image. See <a href="#ImageMorphology.strel"><code>strel</code></a> for more details. If <code>se</code> is not specified, then it will use the <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> with an extra keyword <code>dims</code> to control the dimensions to filter, and half-size <code>r</code> to control the diamond size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; img = falses(7, 7); img[3:5, 3:5] .= true; img
7×7 BitMatrix:
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  1  1  1  0  0
 0  0  1  1  1  0  0
 0  0  1  1  1  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0

julia&gt; Int.(morphogradient(img))
7×7 Matrix{Int64}:
 0  0  0  0  0  0  0
 0  1  1  1  1  1  0
 0  1  1  1  1  1  0
 0  1  1  0  1  1  0
 0  1  1  1  1  1  0
 0  1  1  1  1  1  0
 0  0  0  0  0  0  0

julia&gt; Int.(morphogradient(img, strel_diamond(img))) # use diamond shape SE
7×7 Matrix{Int64}:
 0  0  0  0  0  0  0
 0  0  1  1  1  0  0
 0  1  1  1  1  1  0
 0  1  1  0  1  1  0
 0  1  1  1  1  1  0
 0  0  1  1  1  0  0
 0  0  0  0  0  0  0</code></pre><p><strong>See also</strong></p><ul><li><a href="#ImageMorphology.morpholaplace"><code>morpholaplace</code></a> for the laplacian operator.</li><li><code>ImageBase.FiniteDiff</code> also provides a few finite difference operators, including <code>fdiff</code>, <code>fgradient</code>, etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/morphogradient.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.morpholaplace" href="#ImageMorphology.morpholaplace"><code>ImageMorphology.morpholaplace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">morpholaplace(img; dims=coords_spatial(img), r=1)
morpholaplace(img, se)</code></pre><p>Calculate morphological laplacian of the image.</p><p>The lapalacian operator is defined as <code>∇⁺A - ∇⁻A</code> where <code>∇⁺A</code> is the external gradient <code>A - erode(A, se)</code> and <code>∇⁻A</code> is the internal gradient <code>dilate(A, se) - A</code>. Thus the laplacian is <code>dilate(A, se) + erode(A, se) - 2A</code> in morphology sense.</p><p><code>se</code> is the structuring element that defines the neighborhood of the image. See <a href="#ImageMorphology.strel"><code>strel</code></a> for more details. If <code>se</code> is not specified, then it will use the <a href="#ImageMorphology.strel_box"><code>strel_box</code></a> with an extra keyword <code>dims</code> to control the dimensions to filter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; img = falses(7, 7); img[3:5, 3:5] .= true; img[4, 4] = false; img
7×7 BitMatrix:
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  0  1  1  1  0  0
 0  0  1  0  1  0  0
 0  0  1  1  1  0  0
 0  0  0  0  0  0  0
 0  0  0  0  0  0  0

julia&gt; Int.(morpholaplace(img))
7×7 Matrix{Int64}:
 0  0   0   0   0  0  0
 0  1   1   1   1  1  0
 0  1  -1  -1  -1  1  0
 0  1  -1   1  -1  1  0
 0  1  -1  -1  -1  1  0
 0  1   1   1   1  1  0
 0  0   0   0   0  0  0

julia&gt; Int.(morpholaplace(img, strel_diamond(img))) # use diamond shape SE
7×7 Matrix{Int64}:
 0  0   0   0   0  0  0
 0  0   1   1   1  0  0
 0  1  -1  -1  -1  1  0
 0  1  -1   1  -1  1  0
 0  1  -1  -1  -1  1  0
 0  0   1   1   1  0  0
 0  0   0   0   0  0  0</code></pre><p><strong>See also</strong></p><ul><li><a href="#ImageMorphology.morphogradient"><code>morphogradient</code></a> for the gradient operator.</li><li><code>ImageBase.FiniteDiff</code> also provides a few finite difference operators, including <code>fdiff</code>, <code>fgradient</code>, etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/ops/morpholaplace.jl#L1-L54">source</a></section></article><h2 id="Components-and-segmentation"><a class="docs-heading-anchor" href="#Components-and-segmentation">Components and segmentation</a><a id="Components-and-segmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Components-and-segmentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.label_components" href="#ImageMorphology.label_components"><code>ImageMorphology.label_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">label = label_components(A; bkg = zero(eltype(A)), dims=coords_spatial(A))
label = label_components(A, connectivity; bkg = zero(eltype(A)))</code></pre><p>Find the connected components in an array <code>A</code>. Components are defined as connected voxels that all have the same value distinct from <code>bkg</code>, which corresponds to the &quot;background&quot; component.</p><p>Specify connectivity in one of three ways:</p><ul><li><p>A list indicating which dimensions are used to determine connectivity. For example, <code>dims = (1,3)</code> would not test neighbors along dimension 2 for connectivity. This corresponds to just the nearest neighbors, i.e., default 4-connectivity in 2d and 6-connectivity in 3d.</p></li><li><p>An iterable <code>connectivity</code> object with <code>CartesianIndex</code> elements encoding the displacement of each checked neighbor.</p></li><li><p>A symmetric boolean array of the same dimensionality as <code>A</code>, of size 1 or 3 along each dimension. Each entry in the array determines whether a given neighbor is used for connectivity analyses. For example, in two dimensions <code>connectivity = trues(3,3)</code> would include all pixels that touch the current one, even the corners.</p></li></ul><p>The output <code>label</code> is an integer array, where <code>bkg</code> elements get a value of 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true false false true  false;
            true false true  true  true]
2×5 Matrix{Bool}:
 1  0  0  1  0
 1  0  1  1  1

julia&gt; label_components(A)
2×5 Matrix{Int64}:
 1  0  0  2  0
 1  0  2  2  2

julia&gt; label_components(A; dims=2)
2×5 Matrix{Int64}:
 1  0  0  4  0
 2  0  3  3  3</code></pre><p>With <code>dims=2</code>, entries in <code>A</code> are connected if they are in the same row, but not if they are in the same column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/connected.jl#L3-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.component_boxes" href="#ImageMorphology.component_boxes"><code>ImageMorphology.component_boxes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>component_boxes(labeled_array)</code> -&gt; an array of bounding boxes for each label, including the background label 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/connected.jl#L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.component_lengths" href="#ImageMorphology.component_lengths"><code>ImageMorphology.component_lengths</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>component_lengths(labeled_array)</code> -&gt; an array of areas (2D), volumes (3D), etc. for each label, including the background label 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/connected.jl#L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.component_indices" href="#ImageMorphology.component_indices"><code>ImageMorphology.component_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>component_indices(labeled_array)</code> -&gt; an array of pixels for each label, including the background label 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/connected.jl#L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.component_subscripts" href="#ImageMorphology.component_subscripts"><code>ImageMorphology.component_subscripts</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>component_subscripts(labeled_array)</code> -&gt; an array of pixels for each label, including the background label 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/connected.jl#L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.component_centroids" href="#ImageMorphology.component_centroids"><code>ImageMorphology.component_centroids</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>component_centroids(labeled_array)</code> -&gt; an array of centroids for each label, including the background label 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/connected.jl#L246">source</a></section></article><h2 id="Max-tree"><a class="docs-heading-anchor" href="#Max-tree">Max tree</a><a id="Max-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Max-tree" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.MaxTree" href="#ImageMorphology.MaxTree"><code>ImageMorphology.MaxTree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Max-tree morphological representation of an image.</p><p><strong>Details</strong></p><p>Let&#39;s consider a <em>thresholding</em> operation,</p><pre><code class="language-julia hljs">    mask = [val ≥ threshold for val in image]</code></pre><p>One can identify the connected components (the sets of neighboring true values) in <code>mask</code>. When <em>image thresholding</em> is sequentially applied for all possible thresholds, it generates a collection of connected components that could be organized into a hierarchical structure called <em>component tree</em>. Consider 1D &quot;image&quot; with values 1, 2 and 3:</p><pre><code class="nohighlight hljs">       2233233312223322</code></pre><p>The connected components would be</p><pre><code class="nohighlight hljs">    1: AAAAAAAAAAAAAAAA
    2: BBBBBBBB.CCCCCCC
    3: ..DD.EEE....FF..</code></pre><p>Here, the letters are the labels of the resulting connected components, and <code>.</code> specifies that the pixel value is below the threshold. In this example, the corresponding <em>component tree</em> is:</p><pre><code class="nohighlight hljs">      A
     ⭩ ⭨
    B   C
   ⭩ ⭨   ⭨
  D   E   F</code></pre><p>A <em>max-tree</em> is an efficient representation of the <em>component tree</em>. A connected component <span>$C$</span> at threshold level <span>$t$</span> is represented by the single <em>reference pixel</em> <span>$r$</span> from this level (<code>image[r] == t</code>), which is the parent to all other pixels of <span>$C$</span> and also to the <em>reference pixels</em> of the connected components at higher thresholds, which are the children of <span>$C$</span>. In our example, the reference pixels (denoted by the letter of the corresponding component) would be:</p><pre><code class="nohighlight hljs">    1: ........A.......
    2: B........C......
    3: ..D..E......F...</code></pre><p>I.e.</p><table><tr><th style="text-align: right">Comp</th><th style="text-align: right">Ref.Pixel</th></tr><tr><td style="text-align: right"><em>A</em></td><td style="text-align: right">9</td></tr><tr><td style="text-align: right"><em>B</em></td><td style="text-align: right">1</td></tr><tr><td style="text-align: right"><em>C</em></td><td style="text-align: right">10</td></tr><tr><td style="text-align: right"><em>D</em></td><td style="text-align: right">3</td></tr><tr><td style="text-align: right"><em>E</em></td><td style="text-align: right">6</td></tr><tr><td style="text-align: right"><em>F</em></td><td style="text-align: right">13</td></tr></table><p>So the whole max-tree could be encoded as a vector of indices of parent pixels:</p><pre><code class="nohighlight hljs">9  1  1  3  1  1  6  6  9  9 10 10 10 13 10 10</code></pre><p>The <em>max-tree</em> is the basis for many morphological operators, namely connected operators. Unlike morphological openings and closings, these operators do not require a fixed structuring element, but rather act with a flexible structuring element that meets a certain criterion.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.area_opening"><code>area_opening</code></a>, <a href="#ImageMorphology.area_closing"><code>area_closing</code></a>, <a href="#ImageMorphology.diameter_opening"><code>diameter_opening</code></a>, <a href="#ImageMorphology.diameter_closing"><code>diameter_closing</code></a>.</p><p><strong>References</strong></p><ol><li>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). <em>Antiextensive Connected Operators for Image and Sequence Processing</em>. IEEE Transactions on Image Processing, 7(4), 555-570.<blockquote><p>https://doi.org/10.1109/83.663500</p></blockquote></li><li>Berger, C., Geraud, T., Levillain, R., Widynski, N., Baillard, A., Bertin, E. (2007). <em>Effective Component Tree Computation with Application to Pattern Recognition in Astronomical Imaging</em>. In International Conference on Image Processing (ICIP), 41-44.<blockquote><p>https://doi.org/10.1109/ICIP.2007.4379949</p></blockquote></li><li>Najman, L., &amp; Couprie, M. (2006). <em>Building the component tree in quasi-linear time</em>. IEEE Transactions on Image Processing, 15(11), 3531-3539.<blockquote><p>https://doi.org/10.1109/TIP.2006.877518</p></blockquote></li><li>Carlinet, E., &amp; Geraud, T. (2014). <em>A Comparative Review of Component Tree Computation Algorithms</em>. IEEE Transactions on Image Processing, 23(9), 3885-3895.<blockquote><p>https://doi.org/10.1109/TIP.2014.2336551</p></blockquote></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L1-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.areas" href="#ImageMorphology.areas"><code>ImageMorphology.areas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">areas(maxtree::MaxTree) -&gt; Array{Int}</code></pre><p>Computes the areas of all <code>maxtree</code> components.</p><p><strong>Returns</strong></p><p>The array of the same shape as the original image. The <code>i</code>-th element is the area (in pixels) of the component that is represented by the reference pixel with index <code>i</code>.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.diameters"><code>diameters</code></a>, <a href="#ImageMorphology.area_opening"><code>area_opening</code></a>, <a href="#ImageMorphology.area_closing"><code>area_closing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L282-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.boundingboxes" href="#ImageMorphology.boundingboxes"><code>ImageMorphology.boundingboxes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundingboxes(maxtree::MaxTree) -&gt; Array{NTuple{2, CartesianIndex}}</code></pre><p>Computes the minimal bounding boxes of all <code>maxtree</code> components.</p><p><strong>Returns</strong></p><p>The array of the same shape as the original image. The <code>i</code>-th element is the tuple of the minimal and maximal cartesian indices for the bounding box of the component that is represented by the reference pixel with index <code>i</code>.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.diameters"><code>diameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L305-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.diameters" href="#ImageMorphology.diameters"><code>ImageMorphology.diameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diameters(maxtree::MaxTree) -&gt; Array{Int}</code></pre><p>Computes the &quot;diameters&quot; of all <code>maxtree</code> components.</p><p>&quot;Diameter&quot; of the <em>max-tree</em> connected component is the length of the widest side of the component&#39;s bounding box.</p><p><strong>Returns</strong></p><p>The array of the same shape as the original image. The <code>i</code>-th element is the &quot;diameter&quot; of the component that is represented by the reference pixel with index <code>i</code>.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.boundingboxes"><code>boundingboxes</code></a>, <a href="#ImageMorphology.areas"><code>areas</code></a>, <a href="#ImageMorphology.diameter_opening"><code>diameter_opening</code></a>, <a href="#ImageMorphology.diameter_closing"><code>diameter_closing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L329-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.area_opening" href="#ImageMorphology.area_opening"><code>ImageMorphology.area_opening</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">area_opening(image, [maxtree]; min_area=64, connectivity=1) -&gt; Array</code></pre><p>Performs an <em>area opening</em> of the <code>image</code>.</p><p><em>Area opening</em> replaces all bright components of an image that have a surface smaller than <code>min_area</code> with the darker value taken from their first ancestral component (in <em>max-tree</em> representation of <code>image</code>) that has the area no smaller than <code>min_area</code>.</p><p><strong>Details</strong></p><p>Area opening is similar to morphological opening (see <a href="#ImageMorphology.opening"><code>opening</code></a>), but instead of using a fixed structuring element (e.g. disk) it employs small (less than <code>min_area</code>) components of the <em>max-tree</em>. Consequently, the <code>area_opening</code> with <code>min_area = 1</code> is the identity transformation.</p><p>In the binary case, area opening is equivalent to <code>remove_small_objects</code>; this operator is thus extended to gray-level images.</p><p><strong>Arguments</strong></p><ul><li><code>image::GenericGrayImage</code>: the <span>$N$</span>-dimensional input image</li><li><code>min_area::Number=64</code>: the smallest size (in pixels) of the image component to keep intact</li><li><code>connectivity::Integer=1</code>: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.</li><li><code>maxtree::MaxTree</code>: optional pre-built <em>max-tree</em>. Note that <code>maxtree</code> and <code>connectivity</code> optional parameters are mutually exclusive.</li></ul><p><strong>Returns</strong></p><p>An array of the same type and shape as the <code>image</code>.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.area_opening!"><code>area_opening!</code></a>, <a href="#ImageMorphology.area_closing"><code>area_closing</code></a>, <a href="#ImageMorphology.diameter_opening"><code>diameter_opening</code></a>, <a href="#ImageMorphology.MaxTree"><code>MaxTree</code></a>, <a href="#ImageMorphology.opening"><code>opening</code></a></p><p><strong>References</strong></p><ol><li>Vincent, L. (1993). <em>Grayscale area openings and closings, their efficient implementation and applications</em>, Proc. of EURASIP Workshop on Mathematical Morphology and its Applications to Signal Processing, Barcelona, Spain, 22-27</li><li>Soille, P. (2003). Chapter 6 <em>Geodesic Metrics</em> of <em>Morphological Image Analysis: Principles and Applications</em>, 2nd edition, Springer.<blockquote><p>https://doi.org/10.1007/978-3-662-05088-0</p></blockquote></li><li>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). <em>Antiextensive Connected Operators for Image and Sequence Processing</em>. IEEE Transactions on Image Processing, 7(4), 555-570.<blockquote><p>https://doi.org/10.1109/83.663500</p></blockquote></li><li>Najman, L., &amp; Couprie, M. (2006). <em>Building the component tree in quasi-linear time</em>. IEEE Transactions on Image Processing, 15(11), 3531-3539.<blockquote><p>https://doi.org/10.1109/TIP.2006.877518</p></blockquote></li><li>Carlinet, E., &amp; Geraud, T. (2014). <em>A Comparative Review of Component Tree Computation Algorithms</em>. IEEE Transactions on Image Processing, 23(9), 3885-3895.<blockquote><p>https://doi.org/10.1109/TIP.2014.2336551</p></blockquote></li></ol><p><strong>Examples</strong></p><p>Creating a test image <code>f</code> (quadratic function with a maximum in the center and 4 additional local maxima):</p><pre><code class="language-julia-repl hljs">julia&gt; w = 12;

julia&gt; f = [20 - 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];

julia&gt; f[3:4, 2:6] .= 40; f[3:5, 10:12] .= 60; f[10:12, 3:5] .= 80;

julia&gt; f[10:11, 10:12] .= 100; f[11, 11] = 100;

julia&gt; f_aopen = area_opening(f, min_area=8, connectivity=1);</code></pre><p>The peaks with a surface smaller than 8 are removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L442-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.area_opening!" href="#ImageMorphology.area_opening!"><code>ImageMorphology.area_opening!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">area_opening!(output, image, [maxtree];
              min_area=64, connectivity=1) -&gt; output</code></pre><p>Performs in-place <em>area opening</em> of the <code>image</code> and stores the result in <code>output</code>. See <a href="#ImageMorphology.area_opening"><code>area_opening</code></a> for the detailed description of the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L428-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.area_closing" href="#ImageMorphology.area_closing"><code>ImageMorphology.area_closing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">area_closing(image, [maxtree]; min_area=64, connectivity=1) -&gt; Array</code></pre><p>Performs an <em>area closing</em> of the <code>image</code>.</p><p><em>Area closing</em> replaces all dark components of an image that have a surface smaller than <code>min_area</code> with the brighter value taken from their first ancestral component (in <em>max-tree</em> representation of <code>image</code>) that has the area no smaller than <code>min_area</code>.</p><p><strong>Details</strong></p><p><em>Area closing</em> is the dual operation to <em>area opening</em> (see <a href="#ImageMorphology.area_opening"><code>area_opening</code></a>). It is similar to morphological closings (see <a href="#ImageMorphology.closing"><code>closing</code></a>), but instead of using a fixed structuring element (e.g. disk) it employs small (less than <code>min_area</code>) components of the <em>max-tree</em>. Consequently, the <code>area_closing</code> with <code>min_area = 1</code> is the identity transformation.</p><p>In the binary case, area closing is equivalent to <code>remove_small_holes</code>; this operator is thus extended to gray-level images.</p><p><strong>Arguments</strong></p><ul><li><code>image::GenericGrayImage</code>: the <span>$N$</span>-dimensional input image</li><li><code>min_area::Number=64</code>: the smallest size (in pixels) of the image component to keep intact</li><li><code>connectivity::Integer=1</code>: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.</li><li><code>maxtree::MaxTree</code>: optional pre-built <em>max-tree</em>. Note that <code>maxtree</code> and <code>connectivity</code> optional parameters are mutually exclusive.</li></ul><p><strong>Returns</strong></p><p>An array of the same type and shape as the <code>image</code>.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.area_closing!"><code>area_closing!</code></a>, <a href="#ImageMorphology.area_opening"><code>area_opening</code></a>, <a href="#ImageMorphology.diameter_closing"><code>diameter_closing</code></a>, <a href="#ImageMorphology.MaxTree"><code>MaxTree</code></a>, <a href="#ImageMorphology.closing"><code>closing</code></a></p><p><strong>References</strong></p><ol><li>Vincent, L. (1993). <em>Grayscale area openings and closings, their efficient implementation and applications</em>, Proc. of EURASIP Workshop on Mathematical Morphology and its Applications to Signal Processing, Barcelona, Spain, 22-27</li><li>Soille, P. (2003). Chapter 6 <em>Geodesic Metrics</em> of <em>Morphological Image Analysis: Principles and Applications</em>, 2nd edition, Springer.<blockquote><p>https://doi.org/10.1007/978-3-662-05088-0</p></blockquote></li><li>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). <em>Antiextensive Connected Operators for Image and Sequence Processing</em>. IEEE Transactions on Image Processing, 7(4), 555-570.<blockquote><p>https://doi.org/10.1109/83.663500</p></blockquote></li><li>Najman, L., &amp; Couprie, M. (2006). <em>Building the component tree in quasi-linear time</em>. IEEE Transactions on Image Processing, 15(11), 3531-3539.<blockquote><p>https://doi.org/10.1109/TIP.2006.877518</p></blockquote></li><li>Carlinet, E., &amp; Geraud, T. (2014). <em>A Comparative Review of Component Tree Computation Algorithms</em>. IEEE Transactions on Image Processing, 23(9), 3885-3895.<blockquote><p>https://doi.org/10.1109/TIP.2014.2336551</p></blockquote></li></ol><p><strong>Examples</strong></p><p>Creating a test image <code>f</code> (quadratic function with a minimum in the center and 4 additional local minima):</p><pre><code class="language-julia-repl hljs">julia&gt; w = 12;

julia&gt; f = [180 + 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];

julia&gt; f[3:4, 2:6] .= 40; f[3:5, 10:12] .= 60; f[10:12, 3:5] .= 80;

julia&gt; f[10:11, 10:12] .= 100; f[11, 11] = 100;

julia&gt; f_aclose = area_closing(f, min_area=8, connectivity=1);</code></pre><p>All small minima are removed, and the remaining minima have at least a size of 8.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L594-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.area_closing!" href="#ImageMorphology.area_closing!"><code>ImageMorphology.area_closing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">area_closing!(output, image, [maxtree];
              min_area=64, connectivity=1) -&gt; output</code></pre><p>Performs in-place <em>area closing</em> of the <code>image</code> and stores the result in <code>output</code>. See <a href="#ImageMorphology.area_closing"><code>area_closing</code></a> for the detailed description of the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L580-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.diameter_opening" href="#ImageMorphology.diameter_opening"><code>ImageMorphology.diameter_opening</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diameter_opening(image, [maxtree]; min_diameter=8, connectivity=1) -&gt; Array</code></pre><p>Performs a <em>diameter opening</em> of the <code>image</code>.</p><p><em>Diameter opening</em> replaces all bright structures of an image that have the diameter (the widest dimension of their bounding box) smaller than <code>min_diameter</code> with the darker value taken from their first ancestral component (in <em>max-tree</em> representation of <code>image</code>) that has the diameter no smaller than <code>min_diameter</code>.</p><p>The operator is also called <em>Bounding Box Opening</em>. In practice, the result is similar to a <em>morphological opening</em>, but long and thin structures are not removed.</p><p><strong>Arguments</strong></p><ul><li><code>image::GenericGrayImage</code>: the <span>$N$</span>-dimensional input image</li><li><code>min_diameter::Number=8</code>: the minimal length (in pixels) of the widest dimension of the bounding box of the image component to keep intact</li><li><code>connectivity::Integer=1</code>: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.</li><li><code>maxtree::MaxTree</code>: optional pre-built <em>max-tree</em>. Note that <code>maxtree</code> and <code>connectivity</code> optional parameters are mutually exclusive.</li></ul><p><strong>Returns</strong></p><p>An array of the same type and shape as the <code>image</code>.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.diameter_opening!"><code>diameter_opening!</code></a>, <a href="#ImageMorphology.diameter_closing"><code>diameter_closing</code></a>, <a href="#ImageMorphology.area_opening"><code>area_opening</code></a>, <a href="#ImageMorphology.MaxTree"><code>MaxTree</code></a>, <a href="#ImageMorphology.opening"><code>opening</code></a></p><p><strong>References</strong></p><ol><li>Walter, T., &amp; Klein, J.-C. (2002). <em>Automatic Detection of Microaneurysms in Color Fundus Images of the Human Retina by Means of the Bounding Box Closing</em>. In A. Colosimo, P. Sirabella, A. Giuliani (Eds.), <em>Medical Data Analysis. Lecture Notes in Computer Science</em>, vol 2526, 210-220. Springer Berlin Heidelberg.<blockquote><p>https://doi.org/10.1007/3-540-36104-9_23</p></blockquote></li><li>Carlinet, E., &amp; Geraud, T. (2014). <em>A Comparative Review of Component Tree Computation Algorithms</em>. IEEE Transactions on Image Processing, 23(9), 3885-3895.<blockquote><p>https://doi.org/10.1109/TIP.2014.2336551</p></blockquote></li></ol><p><strong>Examples</strong></p><p>Creating a test image <code>f</code> (quadratic function with a maximum in the center and 4 additional local maxima):</p><pre><code class="language-julia-repl hljs">julia&gt; w = 12;

julia&gt; f = [20 - 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];

julia&gt; f[3:4, 2:6] .= 40; f[3:5, 10:12] .= 60; f[10:12, 3:5] .= 80;

julia&gt; f[10:11, 10:12] .= 100; f[11, 11] = 100;

julia&gt; f_dopen = diameter_opening(f, min_diameter=3, connectivity=1);</code></pre><p>The peaks with a maximal diameter of 2 or less are removed. For the remaining peaks the widest side of the bounding box is at least 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L522-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.diameter_opening!" href="#ImageMorphology.diameter_opening!"><code>ImageMorphology.diameter_opening!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diameter_opening!(output, image, [maxtree];
                  min_diameter=8, connectivity=1) -&gt; output</code></pre><p>Performs in-place <em>diameter opening</em> of the <code>image</code> and stores the result in <code>output</code>. See <a href="#ImageMorphology.diameter_opening"><code>diameter_opening</code></a> for the detailed description of the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L508-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.diameter_closing" href="#ImageMorphology.diameter_closing"><code>ImageMorphology.diameter_closing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diameter_closing(image, [maxtree]; min_diameter=8, connectivity=1) -&gt; Array</code></pre><p>Performs a <em>diameter closing</em> of the <code>image</code>.</p><p><em>Diameter closing</em> replaces all dark structures of an image that have the diameter (the widest dimension of their bounding box) smaller than <code>min_diameter</code> with the brighter value taken from their first ancestral component (in <em>max-tree</em> representation of <code>image</code>) that has the diameter no smaller than <code>min_diameter</code>.</p><p><strong>Arguments</strong></p><ul><li><code>image::GenericGrayImage</code>: the <span>$N$</span>-dimensional input image</li><li><code>min_diameter::Number=8</code>: the minimal length (in pixels) of the widest dimension of the bounding box of the image component to keep intact</li><li><code>connectivity::Integer=1</code>: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.</li><li><code>maxtree::MaxTree</code>: optional pre-built <em>max-tree</em>. Note that <code>maxtree</code> and <code>connectivity</code> optional parameters are mutually exclusive.</li></ul><p><strong>Returns</strong></p><p>An array of the same type and shape as the <code>image</code>.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.diameter_closing!"><code>diameter_closing!</code></a>, <a href="#ImageMorphology.diameter_opening"><code>diameter_opening</code></a>, <a href="#ImageMorphology.area_closing"><code>area_closing</code></a>, <a href="#ImageMorphology.MaxTree"><code>MaxTree</code></a>, <a href="#ImageMorphology.closing"><code>closing</code></a></p><p><strong>References</strong></p><ol><li>Walter, T., &amp; Klein, J.-C. (2002). <em>Automatic Detection of Microaneurysms in Color Fundus Images of the Human Retina by Means of the Bounding Box Closing</em>. In A. Colosimo, P. Sirabella, A. Giuliani (Eds.), <em>Medical Data Analysis. Lecture Notes in Computer Science</em>, vol 2526, 210-220. Springer Berlin Heidelberg.<blockquote><p>https://doi.org/10.1007/3-540-36104-9_23</p></blockquote></li><li>Carlinet, E., &amp; Geraud, T. (2014). <em>A Comparative Review of Component Tree Computation Algorithms</em>. IEEE Transactions on Image Processing, 23(9), 3885-3895.<blockquote><p>https://doi.org/10.1109/TIP.2014.2336551</p></blockquote></li></ol><p><strong>Examples</strong></p><p>Creating a test image <code>f</code> (quadratic function with a minimum in the center and 4 additional local minima):</p><pre><code class="language-julia-repl hljs">julia&gt; w = 12;

julia&gt; f = [180 + 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];

julia&gt; f[3:4, 2:6] .= 40; f[3:5, 10:12] .= 60; f[10:12, 3:5] .= 80;

julia&gt; f[10:11, 10:12] .= 100; f[11, 11] = 100;

julia&gt; f_dclose = diameter_closing(f, min_diameter=3, connectivity=1);</code></pre><p>All small minima with a diameter of 2 or less are removed. For the remaining minima the widest bounding box side is at least 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L676-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.diameter_closing!" href="#ImageMorphology.diameter_closing!"><code>ImageMorphology.diameter_closing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diameter_closing!(output, image, [maxtree];
                  min_diameter=8, connectivity=1) -&gt; output</code></pre><p>Performs in-place <em>diameter closing</em> of the <code>image</code> and stores the result in <code>output</code>. See <a href="#ImageMorphology.diameter_closing"><code>diameter_closing</code></a> for the detailed description of the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L662-L668">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.local_maxima!" href="#ImageMorphology.local_maxima!"><code>ImageMorphology.local_maxima!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_maxima!(output, image, [maxtree]; connectivity=1) -&gt; output</code></pre><p>Detects the local maxima of <code>image</code> and stores the result in <code>output</code>. See <a href="#ImageMorphology.local_maxima"><code>local_maxima</code></a> for the detailed description of the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L771-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.local_maxima" href="#ImageMorphology.local_maxima"><code>ImageMorphology.local_maxima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_maxima(image, [maxtree]; connectivity=1) -&gt; Array</code></pre><p>Determines and labels all <em>local maxima</em> of the <code>image</code>.</p><p><strong>Details</strong></p><p>The <em>local maximum</em> is defined as the connected set of pixels that have the same value, which is greater than the values of all pixels in direct neighborhood of the set.</p><p>Technically, the implementation is based on the <em>max-tree</em> representation of an image. It&#39;s beneficial if the max-tree is already computed, otherwise <code>ImageFiltering.findlocalmaxima</code> would be more efficient.</p><p><strong>Arguments</strong></p><ul><li><code>image::GenericGrayImage</code>: the <span>$N$</span>-dimensional input image</li><li><code>connectivity::Integer=1</code>: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.</li><li><code>maxtree::MaxTree</code>: optional pre-built <em>max-tree</em>. Note that <code>maxtree</code> and <code>connectivity</code> optional parameters are mutually exclusive.</li></ul><p><strong>Returns</strong></p><p>An integer array of the same shape as the <code>image</code>. Pixels that are not local maxima have 0 value. Pixels of the same local maximum share the same positive value (the local maximum id).</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.MaxTree"><code>MaxTree</code></a>, <a href="#ImageMorphology.local_maxima!"><code>local_maxima!</code></a>, <a href="#ImageMorphology.local_minima"><code>local_minima</code></a>, <code>ImageFiltering.findlocalmaxima</code></p><p><strong>Examples</strong></p><p>Create <code>f</code> (quadratic function with a maximum in the center and 4 additional constant maxima):</p><pre><code class="language-julia-repl hljs">julia&gt; w = 10;

julia&gt; f = [20 - 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];

julia&gt; f[3:5, 3:5] .= 40; f[3:5, 8:10] .= 60; f[8:10, 3:5] .= 80; f[8:10, 8:10] .= 100;

julia&gt; f_maxima = local_maxima(f); # Get all local maxima of `f`</code></pre><p>The resulting image contains the 4 labeled local maxima.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L784-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.local_minima!" href="#ImageMorphology.local_minima!"><code>ImageMorphology.local_minima!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_minima!(output, image, [maxtree]; connectivity=1) -&gt; output</code></pre><p>Detects the local minima of <code>image</code> and stores the result in <code>output</code>. See <a href="#ImageMorphology.local_minima"><code>local_minima</code></a> for the detailed description of the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L831-L836">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.local_minima" href="#ImageMorphology.local_minima"><code>ImageMorphology.local_minima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_minima(image, [maxtree]; connectivity=1) -&gt; Array</code></pre><p>Determines and labels all <em>local minima</em> of the <code>image</code>.</p><p><strong>Details</strong></p><p>The <em>local minimum</em> is defined as the connected set of pixels that have the same value, which is less than the values of all pixels in direct neighborhood of the set.</p><p>Technically, the implementation is based on the <em>max-tree</em> representation of an image. It&#39;s beneficial if the max-tree is already computed, otherwise <code>ImageFiltering.findlocalminima</code> would be more efficient.</p><p><strong>Arguments</strong></p><ul><li><code>image::GenericGrayImage</code>: the <span>$N$</span>-dimensional input image</li><li><code>connectivity::Integer=1</code>: the neighborhood connectivity. The maximum number of orthogonal steps to reach a neighbor of the pixel. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood.</li><li><code>maxtree::MaxTree</code>: optional pre-built <em>max-tree</em>. Note that <code>maxtree</code> and <code>connectivity</code> optional parameters are mutually exclusive.</li></ul><p><strong>Returns</strong></p><p>An integer array of the same shape as the <code>image</code>. Pixels that are not local minima have 0 value. Pixels of the same local minimum share the same positive value (the local minimum id).</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.MaxTree"><code>MaxTree</code></a>, <a href="#ImageMorphology.local_minima!"><code>local_minima!</code></a>, <a href="#ImageMorphology.local_maxima"><code>local_maxima</code></a>, <code>ImageFiltering.findlocalminima</code></p><p><strong>Examples</strong></p><p>Create <code>f</code> (quadratic function with a minimum in the center and 4 additional constant minimum):</p><pre><code class="language-julia-repl hljs">julia&gt; w = 10;

julia&gt; f = [180 + 0.2*((x - w/2)^2 + (y-w/2)^2) for x in 0:w, y in 0:w];

julia&gt; f[3:5, 3:5] .= 40; f[3:5, 8:10] .= 60; f[8:10, 3:5] .= 80; f[8:10, 8:10] .= 100;

julia&gt; f_minima = local_minima(f); # Calculate all local minima of `f`</code></pre><p>The resulting image contains the labeled local minima.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L844-L888">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.rebuild!" href="#ImageMorphology.rebuild!"><code>ImageMorphology.rebuild!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rebuild!(maxtree::MaxTree, image::GenericGrayImage,
         neighbors::AbstractVector{CartesianIndex}) -&gt; maxtree</code></pre><p>Rebuilds the <code>maxtree</code> for the <code>image</code> using <code>neighbors</code> as the pixel connectivity specification.</p><p><strong>Details</strong></p><p>The pixels in the connected components generated by the method should be connected to each other by a path through neighboring pixels. The pixels <span>$p_1$</span> and <span>$p_2$</span> are neighbors, if <code>neighbors</code> array contains <span>$d$</span>, such that <span>$p_2 = p_1 + d$</span>.</p><p><strong>See also</strong></p><p><a href="#ImageMorphology.MaxTree"><code>MaxTree</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L186-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.filter_components!" href="#ImageMorphology.filter_components!"><code>ImageMorphology.filter_components!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filter_components!(output::GenericGrayImage, image::GenericGrayImage,
                   maxtree::MaxTree, attrs::AbstractVector,
                   min_attr, all_below_min) -&gt; output</code></pre><p>Filters the connected components of the <code>image</code> and stores the result in <code>output</code>.</p><p>The <span>$output$</span> is the copy of the <span>$image$</span> exluding the connected components, whose attribute value is below <code>min_attr</code>. That is, the pixels of the exluded component are reset to the value of the reference pixel of its first valid ancestor (the connected component with the attribute value greater or equal to <code>min_attr</code>).</p><p><strong>Arguments</strong></p><ul><li><code>maxtree::MaxTree</code>: pre-built max-tree representation of the <code>image</code></li><li><code>attrs::AbstractVector</code>: <code>attrs[i]</code> is the attribute value for the <span>$i$</span>-th  component of the tree (<span>$i$</span> being the linear index of its <em>reference pixel</em>)</li><li><code>all_below_min</code>: the value to fill the <code>output</code> if all attributes of all components (including the root one) are below <code>min_attr</code></li></ul><p><strong>Details</strong></p><p>This function is the basis for <a href="#ImageMorphology.area_opening"><code>area_opening</code></a>, <a href="#ImageMorphology.diameter_opening"><code>diameter_opening</code></a> and similar transformations. E.g. for <a href="#ImageMorphology.area_opening"><code>area_opening</code></a> the attribute is the area of the components. In this case, the max-tree components of the <code>output</code> have area no smaller than <code>min_attr</code> pixels.</p><p>The method assumes that the attribute values are monotone with respect to the components hieararchy, i.e. <span>$attrs[i] &lt;= attrs[maxtree.parentindices[i]]$</span> for each <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/maxtree.jl#L349-L379">source</a></section></article><h2 id="Feature-transform"><a class="docs-heading-anchor" href="#Feature-transform">Feature transform</a><a id="Feature-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Feature-transform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.FeatureTransform.feature_transform" href="#ImageMorphology.FeatureTransform.feature_transform"><code>ImageMorphology.FeatureTransform.feature_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">feature_transform(img::AbstractArray{Bool, N};
                  weights=nothing, nthreads=Threads.nthreads()) -&gt; F</code></pre><p>Compute the feature transform of a binary image <code>I</code>, finding the closest &quot;feature&quot; (positions where <code>I</code> is <code>true</code>) for each location in <code>I</code>.  Specifically, <code>F[i]</code> is a <code>CartesianIndex</code> encoding the position closest to <code>i</code> for which <code>I[F[i]]</code> is <code>true</code>.  In cases where two or more features in <code>I</code> have the same distance from <code>i</code>, an arbitrary feature is chosen. If <code>I</code> has no <code>true</code> values, then all locations are mapped to an index where each coordinate is <code>typemin(Int)</code>.</p><p>Optionally specify the weight <code>w</code> assigned to each coordinate.  For example, if <code>I</code> corresponds to an image where voxels are anisotropic, <code>w</code> could be the voxel spacing along each coordinate axis. The default value of <code>nothing</code> is equivalent to <code>w=(1,1,...)</code>.</p><p>See also: <a href="#ImageMorphology.FeatureTransform.distance_transform"><code>distance_transform</code></a>.</p><p><strong>Citation</strong></p><ul><li>[1] Maurer, Calvin R., Rensheng Qi, and Vijay Raghavan. &quot;A linear time algorithm for computing exact Euclidean distance transforms of binary images in arbitrary dimensions.&quot; <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 25.2 (2003): 265-270.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/feature_transform.jl#L8-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.FeatureTransform.distance_transform" href="#ImageMorphology.FeatureTransform.distance_transform"><code>ImageMorphology.FeatureTransform.distance_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distance_transform(F::AbstractArray{CartesianIndex}, [w=nothing]) -&gt; D</code></pre><p>Compute the distance transform of <code>F</code>, where each element <code>F[i]</code> represents a &quot;target&quot; or &quot;feature&quot; location assigned to <code>i</code>. Specifically, <code>D[i]</code> is the distance between <code>i</code> and <code>F[i]</code>. Optionally specify the weight <code>w</code> assigned to each coordinate; the default value of <code>nothing</code> is equivalent to <code>w=(1,1,...)</code>.</p><p>See also: <a href="#ImageMorphology.FeatureTransform.feature_transform"><code>feature_transform</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/feature_transform.jl#L67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.clearborder" href="#ImageMorphology.clearborder"><code>ImageMorphology.clearborder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cleared_img = clearborder(img)
cleared_img = clearborder(img, width)
cleared_img = clearborder(img, width, background)</code></pre><p>Returns a copy of the original image after clearing objects connected to the border of the image. Parameters:</p><ul><li>img          = Binary/Grayscale input image</li><li>width        = Width of the border examined (Default value is 1)</li><li>background   = Value to be given to pixels/elements that are cleared (Default value is 0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/clearborder.jl#L1-L12">source</a></section></article><h2 id="Misc"><a class="docs-heading-anchor" href="#Misc">Misc</a><a id="Misc-1"></a><a class="docs-heading-anchor-permalink" href="#Misc" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.convexhull" href="#ImageMorphology.convexhull"><code>ImageMorphology.convexhull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">chull = convexhull(img)</code></pre><p>Computes the convex hull of a binary image and returns the vertices of convex hull as a CartesianIndex array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/convexhull.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.isboundary" href="#ImageMorphology.isboundary"><code>ImageMorphology.isboundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isboundary(img::AbstractArray; background = 0, dims = coords_spatial(A), kwargs...)</code></pre><p>Finds the boundaries that are just within each object. <code>background</code> is the scalar value of the background pixels which will not be marked as boundaries. Keyword arguments are passed to <code>extremefilt!</code> which include <code>dims</code> indicating the dimension(s) over which to discover boundaries.</p><p>See also its in-place version <a href="#ImageMorphology.isboundary!"><code>isboundary!</code></a> and the alternative version that finds thick boundaries, <a href="#ImageMorphology.isboundary_thick"><code>isboundary_thick</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">DocTestSetup = quote
    import ImageMorphology: isboundary
end</code></pre><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(Int64, 16, 16); A[4:8, 4:8] .= 5; A[4:8, 9:12] .= 6; A[10:12,13:15] .= 3; A[10:12,3:6] .= 9; A
16×16 Matrix{Int64}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0
 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0
 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0
 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0
 0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0
 0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0
 0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

julia&gt; isboundary(A)
16×16 Matrix{Int64}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0
 0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0
 0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0
 0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0
 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

julia&gt; isboundary(A .!= 0)
16×16 BitMatrix:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0
 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

julia&gt; isboundary(A .!= 0; dims = 1)
16×16 BitMatrix:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

julia&gt; isboundary(A .!= 0; dims = 2)
16×16 BitMatrix:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0
 0  0  0  1  0  0  0  0  0  0  0  1  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0
 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0
 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/isboundary.jl#L52-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.isboundary!" href="#ImageMorphology.isboundary!"><code>ImageMorphology.isboundary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isboundary!(img::AbstractArray; background = 0, dims = coords_spatial(A), kwargs...)</code></pre><p>Finds the boundaries that are just within each object, replacing the original image. <code>background</code> is the scalar value of the background pixels which will not be marked as boundaries. Keyword arguments are passed to <code>extreme_filter</code> which include <code>dims</code> indicating the dimension(s) over which to discover boundaries.</p><p>See out-of-place version, <a href="#ImageMorphology.isboundary"><code>isboundary</code></a>, for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/isboundary.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageMorphology.isboundary_thick" href="#ImageMorphology.isboundary_thick"><code>ImageMorphology.isboundary_thick</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isboundary_thick(img::AbstractArray; dims = coords_spatial(img), kwargs...)</code></pre><p>Find thick boundaries that are just outside and just inside the objects. This is a union of the inner and outer boundaries. Keyword <code>dims</code> indicates over which dimensions to look for boundaries. This <code>dims</code> and additional keywords <code>kwargs</code> are passed to <a href="#ImageMorphology.extreme_filter"><code>extreme_filter</code></a>.</p><p>See also <a href="#ImageMorphology.isboundary"><code>isboundary</code></a> which just yields the inner boundaries.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">DocTestSetup = quote
    import ImageMorphology: isboundary_thick
end</code></pre><p>```jldoctest julia&gt; A = zeros(Int64, 16, 16); A[4:8, 4:8] .= 5; A[4:8, 9:12] .= 6; A[10:12,13:15] .= 3; A[10:12,3:6] .= 9; A 16×16 Matrix{Int64}:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  5  5  5  5  5  6  6  6  6  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0  0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0  0  0  9  9  9  9  0  0  0  0  0  0  3  3  3  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</p><p>julia&gt; isboundary_thick(A) 16×16 BitMatrix:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  0  0  0  0  0  1  1  0  0  0  1  1  0  0  1  1  0  0  0  0  0  1  1  0  0  0  1  1  0  0  1  1  0  0  0  0  0  1  1  0  0  0  1  1  0  0  1  1  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  0  1  1  0  0  1  1  0  0  0  0  1  1  0  1  1  0  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  0  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</p><p>julia&gt; isboundary_thick(A) .&amp; (A .!= 0) 16×16 BitMatrix:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</p><p>julia&gt; isboundary_thick(A) == isboundary(A; background = -1) true</p><p>julia&gt; isboundary_thick(A) .&amp; (A .!= 0) == isboundary(A) # inner boundaries true</p><p>julia&gt; isboundary_thick(A .!= 0) .&amp; (A .== 0)  == isboundary(A .== 0) # outer boundaries true  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageMorphology.jl/blob/4d9c0622b7ce4c52d1fd32b379280536ee156b24/src/isboundary.jl#L217-L301">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Morphology Operators</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 24 May 2022 00:59">Tuesday 24 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
